*********************************************************************
*
* Crazy climber
*
* Rasmus Moustgaard <rasmus.moustgaard@gmail.com>
*
*********************************************************************

       def   start

       copy "macros.a99"

**
* Memory mapped addresses
*
vdpwd:                                 ; VDP write data
       equ  >8c00
vdpwa:                                 ; VDP set read/write address
       equ  >8c02
vdprd:                                 ; VDP read data
       equ  >8800
vdpsta:                                ; VDP status
       equ  >8802
sound:                                 ; Sound
       equ  >8400
spchwt:
       equ  >9400
spchrd:
       equ  >9000


*       VPD RAM Map
pattern_table:                         ; Pattern table base
       equ  >0000
pattern_table_1:                       ; Pattern table part 2
       equ  >0800
pattern_table_2:                       ; Pattern table part 3
       equ  >1000
sprite_pattern_table:                  ; Sprite pattern table
       equ  >1800
color_table:                           ; Color table base
       equ  >2000
name_table_0:                          ; Name table base 0 (>0A)
       equ  >2800
name_table_1:                          ; Name table base 1 (>0B)
       equ  >2C00
sprite_attr_table:                     ; Sprite attribute table
       equ  >3700

*      Constants
map_width:
       equ   22
n_windows:
       equ  6
top_window_row_y:
       equ 128

**
* Scratch pad
*
pad:
       equ  >8300
wrksp:
       equ  pad                        ; Workspace
r0lb:
       equ  wrksp+1
r1lb:
       equ  wrksp+3
r2lb:
       equ  wrksp+5
r3lb:
       equ  wrksp+7
wrksp2:
       equ  wrksp+>20
stack:
       equ  wrksp2+>20
**
* PAD constants
*
padcon:
       equ  stack+>16                  ; Start of pad constants
one:
       equ  padcon
two:
       equ  padcon+2
**
* PAD variables
*
padvar:                                ; Start of pad variables
       equ  two+2
*********************************************************************
*
* Variables and data
*
rand_no:                               ; Random number seed
       equ  padvar
vdp_status:                            ; VDP status byte
       equ  rand_no+2
frame:                                 ; Frame counter
       equ  vdp_status+2
scroll_y:                              ; Vertical scroll offset
       equ  frame+2
scroll_dy:                             ; Scroll direction
       equ  scroll_y+2
left_anim_ptr:                         ; Left animation pointer
       equ  scroll_dy+2
right_anim_ptr:                        ; Right animation pointer
       equ  left_anim_ptr+2
left_ascending:                        ; Flag: ascending on left side?
       equ  right_anim_ptr+2
right_ascending:                       ; Flag: ascending on right side?
       equ  left_ascending+2
left_grip:                             ; Flag: ascending on left side?
       equ  right_ascending+2
right_grip:                            ; Flag: ascending on right side?
       equ  left_grip+2
left_wide:                             ; Flag: ascending on left side?
       equ  right_grip+2
right_wide:                            ; Flag: ascending on right side?
       equ  left_wide+2
animation_count:                       ; Number of frames to repeat last animation frame
       equ  right_wide+2
animation_changed:                     ; Flag: did animation frame (left or right) change?
       equ  animation_count+2
vm8bw_pad:
       equ  animation_changed+2
pad_max:                               ; Max scratchpad address used
       equ  vm8bw_pad+24

********************************************************************************
*
* Main program
*
       aorg >a000                      ; load into upper memory
start  limi 0                          ; disable interrupts
       lwpi wrksp                      ; setup workspace
       li   r10,stack                  ; use r10 as stack pointer
       bl   @one_time_init
*      Init variables
       li   r0,>0bf6                   ; start at the bottom of the map
       mov  r0,@scroll_y
       clr  @scroll_dy
       clr  @frame
       li   r0,left_anim
       mov  r0,@left_anim_ptr
       li   r0,right_anim
       mov  r0,@right_anim_ptr
*      Display initial screen
       bl   @initial_screen
*      Scroll loop
main_loop:
*      Wait for vsync
       bl   @vsync
*      Set name table
       bl   @set_name_table
*      Display sprites
       bl   @display_sprites
*      Control climber
       bl   @control_climber
*      Change scroll offset
       a    @scroll_dy,@scroll_y
*      Animate windows and faces
       bl   @animate_windows
       bl   @create_windows
*      Update patterns
       bl   @update_pattern_table
*      Update name table buffer
       bl   @update_name_table
*      Loop forever
       inc  @frame
       jmp  main_loop
*// main_loop

*********************************************************************
*
* Wait for vsync
*
* Modifies R0
*
vsync:
       movb @vdpsta,@vdp_status        ; clear flag if already set
       clr  r12
vsync1:
       tb   2
       jeq  vsync1
       socb @vdpsta,@vdp_status
       b    *r11
*// vsync

*********************************************************************
*
* Set name table
*
* Altenate between tables 0 and 1
*
* Tables 0 contain 'names' from the low character set (0-127)
* Tables 1 contain 'names' from the high character set (128-255)
*
* Modifies r0
*
set_name_table:
       .proc
       mov  @frame,r0                  ; Get frame
       andi r0,1
       ai   r0,>020a
       bl   @vwtr
       .endproc
*// set_name_table

*********************************************************************
*
* Display sprites
*
display_sprites:
       .proc
       li   r0,sprite_attr_table
       bl   @vwad
       bl   @display_climber_sprites
       bl   @handle_other_sprites
       li   r1,>d000                   ; Write end marker
       movb r1,*r15
       .endproc
*// display_sprites

*********************************************************************
*
* Update pattern and color tables
*
* Alternate between updating low (0-127) or high (128-255) half of
* the character set. The set that is updated is not used (and therefore
* not visible) in the currently displayed name table. This provides the
* desired double buffering effect.
*
* Modifies R0-R4
*
update_pattern_table:
       .proc
*      Calculate VDP RAM destination address
       mov  @frame,r0                  ; Read frame into register
       inv  r0
       andi r0,1
       sla  r0,10                      ; 0 or >400
       ai   r0,pattern_table
*      Calculate cpu ram source address
       mov  @scroll_y,r1               ; scroll offset
       andi r1,>0007                   ; mod 8
       ai   r1,pstrip                  ; add base address of pattern strips
*      Save calculated values
       mov  r0,r4
       mov  r1,r5
*      Copy patterns 1st part
       mov  @tchnum,r2                 ; number of patterns
       bl   @vm8bw8
*      Copy patterns 2nd part
       mov   r4,r0
       ai    r0,>800
       mov   r5,r1
       mov   @tchnum,r2                ; number of patterns
       bl    @vm8bw8
*      Copy patterns 3rd part
       mov   r4,r0
       ai    r0,>1000
       mov   r5,r1
       mov   @tchnum,r2                ; number of patterns
       bl    @vm8bw8
*      Copy colors
       mov  r4,r0
       ai   r0,color_table
       mov  r5,r1
       ai   r1,cstrip-pstrip           ; add offset betweem patterns and colors
       mov  @tchnum,r2                 ; number of patterns
       bl   @vm8bw8
       .endproc
*// update_pattern_table

*********************************************************************
*
* Update name table off-screen buffer
*
* Modifies R0-R4
*
update_name_table:
       .proc
*      Calculate map source address in r1
       mov  @scroll_y,r1               ; get scroll offset in pixels
       srl  r1,3                       ; divide by 8 to get row offset
       mpy  @ms0,r1                    ; multiply by map width to get character offset in r2
       li   r1,md0                     ; get the map base address
       a    r2,r1                      ; add the character offset
       li   r4,24                      ; number of rows to copy
*      Decide which buffer to update
       mov  @frame,r0                  ; Read frame into register
       andi r0,1
       jeq  update_name_table_2
*      Copy to vdp ram buffer
       li   r0,name_table_0+8          ; VDP address
update_name_table_1:
       bl   @copy_row                  ; low character set
       ai   r0,32
       dec  r4
       jne  update_name_table_1
       jmp  update_name_table_4
update_name_table_2:
       li   r0,name_table_1+8          ; VDP address
update_name_table_3:
       bl   @copy_row_hi
       ai   r0,32
       dec  r4
       jne  update_name_table_3
update_name_table_4:
       .endproc
*// update_name_table

*********************************************************************
*
* Animate windows
*
animate_windows:
       .proc
       mov  @frame,r0                  ; Only do this every 8th frame
       andi r0,>0007
       ci   r0,7
       jne  animate_windows_5
       li   r3,windows                 ; List of window animations (inclusing resident faces)
animate_windows_1:
       mov  *r3+,r1                    ; Window y
       jlt  animate_windows_5          ; Negative terminates
       mov  *r3+,r0                    ; Window x (0 - 5)
       bl   @window_map_addr               ; Map address in r2
       mov  *r3+,r5                    ; Get animation type
       mov  *r3,r4                     ; Get animation frame
       sla  r4,1                       ; To word offset
       ci   r5,1                       ; Is it a face animation?
       jne  animate_windows_2          ; No - move on
       ai   r4,face_appear             ; Yes - add base address of face animations
       jmp  animate_windows_4
animate_windows_2:
       cb   @-22(r2),@byte_closed      ; Is window above closed?
       jeq  animate_windows_3          ; No - move on
       ai   r4,close_window_below_open ; Yes - add base address of closing windows below open animation
       jmp  animate_windows_4
animate_windows_3:
       ai   r4,close_window_below_closed ; Add base address of closing windows below closed animation
animate_windows_4:
       mov  *r4,r4                     ; Get address of animation bytes
       movb *r4+,*r2+                  ; Top row
       movb *r4+,*r2
       ai   r2,map_width-1             ; Next row
       movb *r4+,*r2+                  ; Middle row
       movb *r4+,*r2
       ai   r2,map_width-1             ; Next row
       movb *r4+,*r2+                  ; Bottom row
       movb *r4+,*r2
*      Update animation frame
       mov  *r3,r4                     ; Get animation frame
       inc  r4                         ; Increment animation frame
       andi r4,>000f                   ; Wrap at 16
       mov  r4,*r3+                    ; Write it back
       ci   r4,>0007                   ; Is it frame 8?
       jne  animate_windows_1          ; No - next window
       c    @window_anim-window_size(r3),@one ; Is it a face animation?
       jne  animate_windows_1          ; No - next window
       bl   @create_resident           ; Create a new resident sprite
       jmp  animate_windows_1          ; Next window
animate_windows_5:
       .endproc
*// animate_windows

*********************************************************************
*
* Create window animations
*
create_windows:
       .proc
       mov  @frame,r0                  ; Only do this every 16th frame
       andi r0,>000f
       ci   r0,15
       jne  update_windows_2
       mov  @scroll_y,r3
       srl  r3,4                       ; Number of windows scrolled
       ai   r3,12-8                    ; Y coord of bottom window row on screen
       c    r3,@windows_last
       jhe  update_windows_2
       li   r0,windows_2nd_last
       li   r1,windows_last
*      Shift windows list down
       li   r2,n_windows-1             ; Number of windows
create_windows_1:
       mov  *r0+,*r1+
       mov  *r0+,*r1+
       mov  *r0+,*r1+
       mov  *r0+,*r1+
       ai   r0,-16
       ai   r1,-16
       dec  r2
       jne  create_windows_1
*      Add new window
       li   r2,6                       ; X coord between 0 and 5
       bl   @rand_max
       mov  r3,r1                      ; Y coord of bottom window row on screen
       ai   r1,-12                     ; Y coord of top window row on screen
       bl   @window_map_addr               ; Window address in r2
       cb   *r2,@byte_open             ; Is there an open window?
       jne  update_windows_2           ; If not then skip
       li   r3,windows
       mov  r1,*r3+                    ; Write Y coord
       mov  r0,*r3+                    ; Write X coord
       bl   @rand
       andi r0,1                       ; Set type
       mov  r0,*r3+                    ; 0 = empty window, 1 = window with resident
       clr  *r3                        ; Clear frame
update_windows_2:
       .endproc
*// update_windows

*********************************************************************
*
* Control climber
*
control_climber:
       .proc
       mov  @animation_count,r1        ; Is an animation count already taking place?
       jeq  control_climber_1          ; Skip ahead if not
       b    @control_climber_11        ; Branch to decrement counter
control_climber_1:
       clr  @animation_changed
       clr  @scroll_dy
*      Left
       mov  @left_anim_ptr,r3          ; Get pointer for left side animation
*      Left maybe check down
       ci   r3,left_anim_last          ; Last frame?
       jeq  control_climber_4
*      Left check down
       li   r0,KEY_D                   ; Check down key
       bl   @check_key
       jeq  control_climber_4          ; Move on if not pressed
       ci   r3,left_anim               ; Is it the first frame
       jne  control_climber_3          ; No - move on
       seto @left_ascending            ; Yes - set ascending flag
control_climber_3:
       ai   r3,spr_anim_size           ; Next frame
       mov  r3,@left_anim_ptr          ; Save new pointer
       mov  @left_ascending,r0         ; Ascending?
       jeq  control_climber_5          ; No - move on
       mov  @right_ascending,r0
       jeq  control_climber_3a
       mov  r3,r4
       ai   r4,-left_anim
       mov  @right_anim_ptr,r5
       ai   r5,-right_anim
       c    r4,r5
       jle  control_climber_3b
control_climber_3a:
       li   r0,-2                      ; Yes - scroll down 2 pixels
       mov  r0,@scroll_dy
control_climber_3b:
       ci   r3,left_anim_last          ; Is it now the last frame?
       jne  control_climber_5          ; No - move on
       clr  @left_ascending            ; Yes - clear ascending flag
       jmp  control_climber_5
control_climber_4:
*      Left, maybe check up
       ci   r3,left_anim               ; First frame?
       jeq  control_climber_6
       mov  @left_ascending,r0
       jne  control_climber_6          ; Can't descend again while ascending
*      Left, check up
       li   r0,KEY_E                   ; Check up key
       bl   @check_key
       jeq  control_climber_6          ; Move on if not pressed
       ai   r3,-spr_anim_size          ; Previous frame
       mov  r3,@left_anim_ptr          ; Save new pointer
control_climber_5:
       mov  *r3+,r1                    ; Pointer to top/bottom body sprite patterns
       movb *r1+,@sprite_attributes_body+2
       movb *r1,@sprite_attributes_body+10
       mov  *r3+,r1                    ; Pointer to head/hands sprite pattern
       movb *r1+,@sprite_attributes_head+10
       movb *r1,@sprite_attributes_head+2
       mov  @two,@animation_count      ; Animation count = 2
       seto @animation_changed
*      Right
control_climber_6:
       mov  @right_anim_ptr,r3         ; Get pointer for right side animation
*      Right, maybe check down
       ci   r3,right_anim_last         ; Last frame?
       jeq  control_climber_8
*      Right check down
       li   r0,KEY_K                   ; Check down key
       bl   @check_key
       jeq  control_climber_8          ; Move on if not pressed
       ci   r3,right_anim              ; Is it the first frame
       jne  control_climber_7          ; No - move on
       seto @right_ascending           ; Yes - climber is ascending
control_climber_7:
       ai   r3,spr_anim_size           ; Next frame
       mov  r3,@right_anim_ptr         ; Save new pointer
       mov  @right_ascending,r0        ; Ascending?
       jeq  control_climber_9          ; No - move on
       mov  @left_ascending,r0
       jeq  control_climber_7a
       mov  r3,r4
       ai   r4,-right_anim
       mov  @left_anim_ptr,r5
       ai   r5,-left_anim
       c    r4,r5
       jle  control_climber_7b
control_climber_7a:
       li   r0,-2                      ; Scroll down 2 pixels
       mov  r0,@scroll_dy
control_climber_7b:
       ci   r3,right_anim_last         ; Is it now the last frame?
       jne  control_climber_9          ; No - move on
       clr  @right_ascending           ; Yes - climber has stopped ascending
       jmp  control_climber_9
control_climber_8:
*      Right, maybe check up
       ci   r3,right_anim              ; First frame?
       jeq  control_climber_10
       mov  @right_ascending,r0
       jne  control_climber_10         ; Can't descend again while ascending
*      Right, check up
       li   r0,KEY_I                   ; Check up key
       bl   @check_key
       jeq  control_climber_10         ; Move on if not pressed
       ai   r3,-spr_anim_size          ; Previous frame
       mov  r3,@right_anim_ptr         ; Save new pointer
control_climber_9:
       mov  *r3+,r1                    ; Pointer to top/bottom body sprite patterns
       movb *r1+,@sprite_attributes_body+6
       movb *r1,@sprite_attributes_body+14
       mov  *r3+,r1                    ; Pointer to head/hands sprite pattern
       movb *r1+,@sprite_attributes_head+14
       movb *r1,@sprite_attributes_head+6
       mov  @two,@animation_count      ; Animation count = 2
       seto @animation_changed
control_climber_10:
       abs  @animation_changed
       jeq  control_climber_12
control_climber_11:
       dec  @animation_count
control_climber_12:
       .endproc
*// control_climber

*********************************************************************
*
* Display climber sprites
*
display_climber_sprites:
       .proc
       mov  @vdp_status,r0
       andi r0,>4000                   ; Test 5th sprite flag
       jeq  display_climber_sprites_1
       li   r1,sprite_attributes_body
       li   r2,2
       jmp  display_climber_sprites_4
display_climber_sprites_1:
       movb @sprite_attributes_head+2,r0
       jeq  display_climber_sprites_2
       li   r0,sprite_attributes_head
       movb *r0+,*r15
       movb *r0+,*r15
       movb *r0+,*r15
       movb *r0+,*r15
display_climber_sprites_2:
       movb @sprite_attributes_head+6,r0
       jeq  display_climber_sprites_3
       li   r0,sprite_attributes_head+4
       movb *r0+,*r15
       movb *r0+,*r15
       movb *r0+,*r15
       movb *r0+,*r15
display_climber_sprites_3:
       li   r1,sprite_attributes_head+8
       li   r2,3
display_climber_sprites_4:
       clr  r3
       bl   @vm8bw_pad
       .endproc
*// display_climber_sprites

*********************************************************************
*
* Handle other sprites
*
handle_other_sprites:
       .proc
       li   r3,sprites
handle_other_sprites_1:
       mov  *r3,r0
       jeq  handle_other_sprites_2
       bl   *r0
handle_other_sprites_2:
       ai   r3,sprite_size
       ci   r3,sprites_end
       jl   handle_other_sprites_1
       .endproc
*// handle_other_sprites

*********************************************************************
*
* Resident person handler
*
* r3: sprite structure
*
resident_handler:
       .proc
       mov  @sprite_count(r3),r0       ; Init?
       jne  resident_handler_1         ; Jump if not
       li   r0,48
       mov  r0,@sprite_count(r3)
resident_handler_1:
       mov  @sprite_x(r3),r0
       mov  @sprite_y(r3),r1
       bl   @window_screen_coords
       dec  r1
       swpb r1
       movb r1,*r15
       swpb r0
       movb r0,*r15
       li   r0,spr_resident*256
       movb r0,*r15
       li   r0,>0f00                   ; White
       movb r0,*r15
       c    @sprite_count(r3),@resident_handler_drop
       jne  resident_handler_2
       bl   @rand
       ci   r0,>c000
       jl   resident_handler_2
       bl   @create_plant
resident_handler_2:
       dec  @sprite_count(r3)
       jne  resident_handler_3
       clr  *r3                        ; Handler done
resident_handler_3:
       .endproc
resident_handler_drop:
       data 32
*// resident_handler

*********************************************************************
*
* Dropping plant handler
*
* r3: sprite structure
*
plant_handler:
       .proc
       mov  @sprite_y(r3),r1
       dec  r1
       swpb r1
       movb r1,*r15
       mov  @sprite_x(r3),r0
       swpb r0
       movb r0,*r15
       li   r0,spr_plant_1*256
       movb r0,*r15
       li   r0,>0c00                   ; Green
       movb r0,*r15
       mov  @sprite_y(r3),r0
       s    @scroll_dy,r0
       inct r0
       mov  r0,@sprite_y(r3)
       ci   r0,194
       jl   plant_handler_1
       clr  @sprite_handler(r3)
plant_handler_1:
       .endproc
*// plant_handler

*********************************************************************
*
* Create resident
*
* r3 points to window structure of next window (must be preserved)
*
create_resident:
       .proc
       bl   @allocate_sprite
       mov  r4,r4
       jeq  create_resident_1
       li   r0,resident_handler
       mov  r0,*r4+                            ; Handler
       mov  @window_row-window_size(r3),*r4+   ; y
       mov  @window_col-window_size(r3),*r4+   ; x
       clr  *r4                                ; Counter
create_resident_1:
       .endproc
*// create_resident

*********************************************************************
*
* Create plant
*
* r3 points to sprite structure of resident (must be preserved)
*
create_plant:
       .proc
       bl   @allocate_sprite
       mov  r4,r4
       jeq  create_plant_1
       li   r0,plant_handler
       mov  r0,*r4+                    ; Handler
       mov  @sprite_x(r3),r0
       mov  @sprite_y(r3),r1
       bl   @window_screen_coords
       ai   r1,16
       mov  r1,*r4+                    ; y
       mov  r0,*r4+                    ; x
       clr  *r4                        ; Counter
create_plant_1:
       .endproc
*// create_plant

*********************************************************************
*
* Allocate sprite
*
* Return sprite address in r4 or zero if no sprte available
*
allocate_sprite:
       li   r4,sprites
allocate_sprite_1:
       mov  *r4,*r4
       jeq  allocate_sprite_2
       ai   r4,sprite_size
       ci   r4,sprites_end
       jne  allocate_sprite_1
       clr  r4
allocate_sprite_2:
       rt
*// allocate_sprite

*********************************************************************
*
* Window address in map
*
* r0: window column
* r1: window row
*
* On return r2 contains the address in the map
*
window_map_addr:
       .push r1
       mpy  @MS0,r1                    ; Multiply by map width to r2
       sla  r2,1                       ; Two rows per window
       ai   r2,top_window_row+2        ; Add address of top of building + offset for left wall
       a    r0,r2                      ; Add x to address x 1
       a    r0,r2                      ; Add x to address x 2
       a    r0,r2                      ; Add x to address x 3
       .pop r1
       rt
*// window_map_addr

*********************************************************************
*
* Window screen coordinates
*
* r0: window column
* r1: window row
*
* On return r0 and r1 contain the screen coordinates (x, y), r2 is modified
*
window_screen_coords:
       sla  r0,3                       ; column * 8
       mov  r0,r2
       sla  r0,1                       ; column * 16
       a    r2,r0                      ; column * 24
       ai   r0,>50                     ; Add offset from left
       sla  r1,4                       ; row * 16
       s    @scroll_y,r1               ; Minus scroll offsset
       ai   r1,top_window_row_y
       rt
*// window_screen_coords

*********************************************************************
*
* Generate a pseudo random number within the given limit
*
* R2: Maximum number (0 - 255) exclusive
*
* On return R0 contains the number [0; R1[
*
rand_max:
       .proc
       bl   @rand                      ; generate a random number in r0
       andi r0,>00ff                   ; clear msb: [0-255]
       mpy  r2,r0                      ; width * [0-255]
       srl  r1,8                       ; (width * [0-255]) / 256
       mov  r1,r0                      ; copy result back
       .endproc
*// rand_max

*********************************************************************
*
* Generate a pseudo random number
*
* On return R0 contains the number, which is also stored at @RANDNO
*
* r0 and r1 are modified
*
rand:
       li   r0,28643                   ; A prime number to multiply by
       mpy  @rand_no,r0                ; Multiply by last random number
       ai   r1,31873                   ; Add a prime number
       src  r1,7                       ; Mix up the number to break odd/even pattern
       mov  r1,@rand_no                ; Save this number for next time
       mov  r1,r0
       rt
*// rand

*********************************************************************
*
* Display initial screen
*
* If sprites beyond 0-7 are to be used on a real 9918A VDP we need to update
* the second and third part of the pattern table as well (with the same 
* patterns). The color table is always OK at >800 bytes. See GMODE.
*
* Note that the pattern frame that should be uploaded here depends on the 
* initial direction of the scrolling. If you want to start at the bottom 
* you should start at frame 7 or 15, to allow enouh frames for building 
* the next name table. This means that the address PSTRIP+7 should be used
* instead of PSTRIP, and @SCRLY should be initilized so that the 3 least 
* significant bits are all ones, e.g. 511 - not 512.
*
initial_screen:
       .proc
*      Upload patterns 1st part
       li   r0,65*8+pattern_table      ; Non-scrolling characters
       li   r1,PAT65
       li   r2,55*8
       bl   @vmbw
       li   r0,pattern_table           ; destination address in vdp ram
       li   r1,PSTRIP+6                ; address of first scrolled pattern frame
       mov  @tchnum,r2                 ; number of patterns of 8 bytes
       bl   @vm8bw8                    ; call copying routine
*      Upload patterns 2nd part
       li   r0,65*8+pattern_table_1    ; Non-scrolling characters
       li   r1,PAT65
       li   r2,55*8
       bl   @vmbw
       li   r0,pattern_table_1         ; destination address in vdp ram
       li   r1,PSTRIP+6                ; address of first scrolled pattern frame
       mov  @tchnum,r2                 ; number of patterns of 8 bytes
       bl   @vm8bw8                    ; call copying routine
*      Upload patterns 3rd part
       li   r0,65*8+pattern_table_2    ; Non-scrolling characters
       li   r1,PAT65
       li   r2,55*8
       bl   @vmbw
       li   r0,pattern_table_2         ; destination address in vdp ram
       li   r1,PSTRIP+6                ; address of first scrolled pattern frame
       mov  @tchnum,r2                 ; number of patterns of 8 bytes
       bl   @vm8bw8                    ; call copying routine
*      Upload colors
       li   r0,65*8+color_table        ; Non-scrolling colors
       li   r1,COL65
       li   r2,55*8
       bl   @vmbw
       LI   r0,color_table             ; Destination address in VDP RAM
       li   r1,CSTRIP+6                ; address of first scrolled color frame
       mov  @tchnum,r2                 ; number of pattern colors of 8 bytes
       bl   @vm8bw8                    ; call copying routine
*      Init name tables
       mov  @scroll_y,r4               ; get initial scroll offset in pixels
       srl  r4,3                       ; convert to row offset
       mov  r4,r5
       mpy  @MS0,r5                    ; convert to map offset in r6
*      Table 0
       li   r0,name_table_0
       li   r1,MD2
       li   r2,>300
       bl   @vmbw
       li   r0,name_table_0+8          ; destination address in vdp ram
       li   r1,md0                     ; base address of map data
       a    r6,r1                      ; add map offset
       li   r7,24                      ; number of rows
inisc1:
       bl   @copy_row
       ai   r0,32
       dec  r7
       jne  inisc1
*      Table 1
       li   r0,name_table_1
       li   r1,MD2
       li   r2,>300
       bl   @vmbw
       li   r0,name_table_1+8          ; destination address in vdp ram
       li   r1,MD0                     ; base address of map data
       a    r6,r1                      ; add map offset
       li   r7,24                      ; number of rows
inisc2:
       bl   @copy_row_hi
       ai   r0,32
       dec  r7
       jne  inisc2
       .endproc
*// initial_screen

*********************************************************************
*
* One time initializations
*
one_time_init:
       .proc
       li   r15,vdpwd
       li   r0,1
       mov  r0,@one
       li   r0,2
       mov  r0,@two
       mov  @>83c0,@rand_no
*      Clear scratchpad
       li   r0,padvar
       li   r2,pad_max-padvar
       bl   @clear
*      Copy code to scratchpad
       li   r0,vm8bw1
       li   r1,vm8bw_pad
       li   r2,vm8bw1_end-vm8bw1
       bl   @copy
*      setup graphics mode
       bl   @graphics_mode             ; call setup routine
*      Sprite patterns
       li   r0,sprite_pattern_table
       li   r1,SPR0
       li   r2,64*32
       bl   @vmbw
*      Sprite attributes
       li   r0,sprite_attr_table
       li   r1,sprite_attributes_body
       li   r2,16
       bl   @vmbw
*      Clear sprites table
       li   r0,sprites
       li   r2,sprites_end-sprites
       bl   @clear
       .endproc
*// one_time_init

*********************************************************************
*
* Set graphics mode
*
graphics_mode:
       .proc
       clr  r0
       li   r1,vdp_registers
       li   r2,8
graphics_mode_1:
       movb *r1+,@r0lb
       bl   @vwtr                      ; Set register
       ai   r0,>0100
       dec  r2
       jne  graphics_mode_1
*      Clear VDP RAM
       clr  r0
       clr  r1
       li   r2,>4000
       bl   @vsmw
*      Disable sprites
       li   r0,sprite_attr_table
       li   r1,>d000
       bl   @vsbw
       .endproc
*      VDP registers
vdp_registers:
       byte >02                        ; Graphics II mode
       byte >e2                        ; 16K, display on, interrupt
       byte name_table_0/>400          ; Name table
       byte >9f                        ; Color table
       byte pattern_table/>800+>03     ; Pattern table x 3
       byte sprite_attr_table/>80      ; Sprite attribute table
       byte sprite_pattern_table/>800  ; Sprite pattern table
       byte >07                        ; Backdrop color
*// graphics_mode

*********************************************************************
*
* Clear CPU memory
*
clear:
       clr  *r0+
       dect r2
       jne  clear
       rt
*// clear


*********************************************************************
*
* Copy CPU memory
*
copy:
       mov  *r0+,*r1+
       dect r2
       jne  copy
       rt
*// copy

***************************************************************************
*
* Check key
*
* r0: Column in MSB: >0000 - >0700, Row in LSB: >0006 - >0014
*
*       Column   0      1    2    3    4    5     6       7
*     Row
*     >0006      =      .    ,    M    N    /    Fire    Fire
*     >0008    Space    L    K    J    H    ;    Left    Left
*     >000A    Enter    O    I    U    Y    P    Right   Right
*     >000C             9    8    7    6    0    Down    Down
*     >000E    Fctn     2    3    4    5    1    Up      Up
*     >0010    Shift    S    D    F    G    A
*     >0012    Ctrl     W    E    R    T    Q
*     >0014             X    C    V    B    Z
*
* On return NEQ means that the key is pressed
*
KEY_FI EQU  >0606
KEY_LF EQU  >0608
KEY_RG EQU  >060A
KEY_DN EQU  >060C
KEY_UP EQU  >060E
KEY_CM EQU  >0206
KEY_FS EQU  >0106
KEY_0  EQU  >050C
KEY_1  EQU  >050E
KEY_2  EQU  >010E
KEY_3  EQU  >020E
KEY_4  EQU  >030E
KEY_5  EQU  >040E
KEY_6  EQU  >040C
KEY_7  EQU  >030C
KEY_8  EQU  >020C
KEY_9  EQU  >010C
KEY_A  EQU  >0510
KEY_B  EQU  >0414
KEY_C  EQU  >0214
KEY_D  EQU  >0210
KEY_E  EQU  >0212
KEY_F  EQU  >0310
KEY_G  EQU  >0410
KEY_H  EQU  >0408
KEY_I  EQU  >020A
KEY_J  EQU  >0308
KEY_K  EQU  >0208
KEY_L  EQU  >0108
KEY_M  EQU  >0306
KEY_N  EQU  >0406
KEY_O  EQU  >010A
KEY_P  EQU  >050A
KEY_Q  EQU  >0512
KEY_R  EQU  >0312
KEY_S  EQU  >0110
KEY_T  EQU  >0412
KEY_U  EQU  >030A
KEY_V  EQU  >0314
KEY_W  EQU  >0112
KEY_X  EQU  >0114
KEY_Y  EQU  >040A
KEY_Z  EQU  >0514
KEY_SP EQU  >0008
KEY_EN EQU  >000A
KEY_FN EQU  >000E
KEY_SH EQU  >0010
KEY_CT EQU  >0012
JOY_FI EQU  >0606
JOY_LT EQU  >0608
JOY_RT EQU  >060A
JOY_DN EQU  >060C
JOY_UP EQU  >060E
*
check_key:
       li   r12,>0024                  ; CRU address of the column decoder
       ldcr r0,3                       ; Select column
       andi r0,>00ff
       mov  r0,r12                     ; Select row
       tb   0                          ; Test key, EQ if not pressed
       rt
*// check_key

*********************************************************************
*
*       Includes
*
       copy "vdp.a99"

*********************************************************************
*
*       Data
*
       copy "graphics.a99"
       copy "screen.a99"
       copy "sprite-patterns.a99"
       copy "map-animations.a99"
       copy "sprite-animations.a99"

window_row:
       equ  0
window_col:
       equ  2
window_anim:
       equ  4
window_frame:
       equ  6
window_size:
       equ  8

windows:
       data 177,4,0,14
       data 179,3,1,1
       data 180,3,0,7
       data 183,5,0,0
windows_2nd_last:
       data 184,2,0,2
windows_last:
       data 186,0,0,0
       data -1
byte_closed:
       byte >00
byte_open:
       byte >36

sprite_attributes_head:
       byte >6f,>a8,0,>06
       byte >6f,>b8,0,>06
       byte >5f,>a8,spr_lft_top_2nd_norm_1,>06
       byte >5f,>b8,spr_rgt_top_2nd_norm_1,>06
sprite_attributes_body:
       byte >5f,>a8,spr_lft_top_norm_1,>02
       byte >5f,>b8,spr_rgt_top_norm_1,>02
       byte >6f,>a8,spr_lft_bot_norm_1,>02
       byte >6f,>b8,spr_rgt_bot_norm_1,>02

sprite_handler:
       equ  0
sprite_y:
       equ  2
sprite_x:
       equ  4
sprite_count:
       equ  6
sprite_size:
       equ  8

       even
sprites:
       bss 16*sprite_size
sprites_end:
       equ  $

       end  start
