*********************************************************************
*
* Crazy climber
*
* Rasmus Moustgaard <rasmus.moustgaard@gmail.com>
*
*********************************************************************

       def   start

       copy "macros.a99"

**
* Memory mapped addresses
*
vdpwd:                                 ; VDP write data
       equ  >8c00
vdpwa:                                 ; VDP set read/write address
       equ  >8c02
vdprd:                                 ; VDP read data
       equ  >8800
vdpsta:                                ; VDP status
       equ  >8802
sound:                                 ; Sound
       equ  >8400
spchwt:
       equ  >9400
spchrd:
       equ  >9000


*       VPD RAM Map
pattern_table:
       EQU  >0000                      ; Pattern table base
PTRNT1:
       EQU  >0800                      ; Pattern table part 2
PTRNT2:
       EQU  >1000                      ; Pattern table part 3
sprite_pattern_table:
       EQU  >1800                      ; Sprite pattern table (>03)
color_table:
       EQU  >2000                      ; Color table base
name_table_0:
       EQU  >2800                      ; Name table base 0 (>0A)
name_table_1:
       EQU  >2C00                      ; Name table base 1 (>0B)
name_table_2:
       EQU  >3000                      ; Name table base 2 (>0C)
name_table_3:
       EQU  >3400                      ; Name table base 3 (>0D)
sprite_attr_table:
       EQU  >3700                      ; Sprite attribute table (>6E)

*      Constants
map_width:
       equ   22
n_windows:
       equ  6

**
* Scratch pad
*
pad:
       equ  >8300
wrksp:
       equ  pad                        ; Workspace
r0lb:
       equ  wrksp+1
r1lb:
       equ  wrksp+3
r2lb:
       equ  wrksp+5
r3lb:
       equ  wrksp+7
wrksp2:
       equ  wrksp+>20
stack:
       equ  wrksp2+>20
**
* PAD constants
*
padcon:
       equ  stack+>16                  ; Start of pad constants
one:
       equ  padcon
eight:
       equ  padcon+2
**
* PAD variables
*
padvar:                                ; Start of pad variables
       equ  eight+2
*********************************************************************
*
* Variables and data
*
rand_no:
       equ  padvar
frame:
       equ  rand_no+2
scroll_y:
       equ  frame+2                    ; Vertical scroll offset
scroll_frame:
       equ  scroll_y+2                 ; Scroll frame (0-15) = SCRLY mod 16
scroll_dy:
       equ  scroll_frame+2             ; Scroll direction (1 or -1)
scroll_max:
       equ  scroll_dy+2                ; Maximimum scroll offset
pad_max:
        equ  scroll_max+2

********************************************************************************
*
* Main program
*
       aorg >a000                      ; load into upper memory
start  limi 0                          ; disable interrupts
       lwpi wrksp                      ; setup workspace
       li   r10,stack                  ; use r10 as stack pointer
       li   r15,vdpwd
       li   r0,1
       mov  r0,@one
       li   r0,8
       mov  r0,@eight
       mov  @>83c0,@rand_no
*      setup graphics mode
       bl   @graphics_mode             ; call setup routine
*      init variables
       mov  @ms0+2,r0                  ; get map height in rows
       ai   r0,-24                     ; subtract one screen
       sla  r0,3                       ; convert to pixels
       mov  r0,@scroll_max             ; this is where scrolling should stop
       li   r0,>0bf7                   ; start at the bottom of the map
       mov  r0,@scroll_y
       seto @scroll_dy                 ; scroll upwards
       li   r0,>0007
       clr  @frame
*      display initial screen
       bl   @initial_screen
*      scroll loop
main_loop:
       mov  @scroll_y,r0               ; get scroll position
       andi r0,>000f                   ; frame = position mod 16
       mov  r0,@scroll_frame           ; write it back
*      wait for vsync
       bl   @vsync
*      set name table
       bl   @set_name_table
*      update patterns
       bl   @update_pattern_table
       bl   @update_name_table
*      animate window
       bl   @animate_windows
       bl   @create_windows
*      update name table buffer
*      change scroll offset
       a    @scroll_dy,@scroll_y
       jeq  chgdy                      ; check if at top
       c    @scroll_y,@scroll_max      ; check if at bottom
       jh   chgdy
*      loop forever
       inc  @frame
       jmp  main_loop
*      change direction
chgdy  neg  @scroll_dy
       bl   @update_full_name_table
       jmp  main_loop

*********************************************************************
*
* Animate windows
*
animate_windows:
       .proc
       mov  @scroll_y,r0
       andi r0,>0007
       jne  animate_windows_5
       li   r3,windows
animate_windows_1:
       mov  *r3+,r1                    ; Window y
       jlt  animate_windows_5          ; Negative terminates
       mov  *r3+,r0                    ; Window x (0 - 5)
       bl   @window_addr               ; Map address in r2
       mov  *r3+,r5                    ; Get animation type
       mov  *r3,r4                     ; Get animation frame
       sla  r4,1                       ; To word offset
       ci   r5,1
       jne  animate_windows_2
       ai   r4,face_appear
       jmp  animate_windows_4
animate_windows_2:
       cb   @-22(r2),@byte_closed      ; Is window above closed?
       jeq  animate_windows_3
       ai   r4,close_window_below_open ; Add animation table base
       jmp  animate_windows_4
animate_windows_3:
       ai   r4,close_window_below_closed
animate_windows_4:
       mov  *r4,r4                     ; Get address of animation bytes
       movb *r4+,*r2+                  ; Top row
       movb *r4+,*r2
       ai   r2,map_width-1             ; Next row
       movb *r4+,*r2+                  ; Middle row
       movb *r4+,*r2
       ai   r2,map_width-1             ; Next row
       movb *r4+,*r2+                  ; Bottom row
       movb *r4+,*r2
*      Update anumation frame
       mov  *r3,r4                     ; Get animation frame
       inc  r4                         ; Increment animation frame
       andi r4,>000f                   ; Wrap at 16
       mov  r4,*r3+                    ; Write it back
       jmp  animate_windows_1          ; Next window
animate_windows_5:
       .endproc
*// animate_windows

*********************************************************************
*
* Create window animations
*
create_windows:
       .proc
       mov  @scroll_frame,r0
       ci   r0,15
       jne  update_windows_2
       mov  @scroll_y,r3
       srl  r3,4                       ; Number of windows scrolled
       ai   r3,12-8                    ; Y coord of bottom window row on screen
       c    r3,@windows_last
       jhe  update_windows_2
       li   r0,windows_2nd_last
       li   r1,windows_last
*      Shift windows list down
       li   r2,n_windows-1             ; Number of windows
create_windows_1:
       mov  *r0+,*r1+
       mov  *r0+,*r1+
       mov  *r0+,*r1+
       mov  *r0+,*r1+
       ai   r0,-16
       ai   r1,-16
       dec  r2
       jne  create_windows_1
*      Add new window
       li   r2,6                       ; X coord between 0 and 5
       bl   @rand_max
       mov  r3,r1                      ; Y coord of bottom window row on screen
       ai   r1,-12                     ; Y coord of top window row on screen
       bl   @window_addr               ; Window address in r2
       cb   *r2,@byte_open             ; Is there an open window?
       jne  update_windows_2           ; If not then skip
       li   r3,windows
       mov  r1,*r3+                    ; Write Y coord
       mov  r0,*r3+                    ; Write X coord
       bl   @rand
       andi r0,1
       mov  r0,*r3+                    ; Set type
       clr  *r3                        ; Clear frame
update_windows_2:
       .endproc
*// update_windows

*********************************************************************
*
* Window address
*
* r0: window x
* r1: window y
*
* On return r2 contains the address in the map
*
window_addr:
       mov  r1,@window_addr_tmp
       mpy  @MS0,r1                    ; Multiply by map width to r2
       sla  r2,1                       ; Two rows per window
       ai   r2,top_window_row+2        ; Add address of top of building + offset for left wall
       a    r0,r2                      ; Add x to address x 1
       a    r0,r2                      ; Add x to address x 2
       a    r0,r2                      ; Add x to address x 3
       mov  @window_addr_tmp,r1
       rt
window_addr_tmp:
       data 0

*********************************************************************
*
* Generate a pseudo random number within the given limit
*
* R2: Maximum number (0 - 255) exclusive
*
* On return R0 contains the number [0; R1[
*
rand_max:
       .proc
       bl   @rand                      ; generate a random number in r0
       andi r0,>00ff                   ; clear msb: [0-255]
       mpy  r2,r0                      ; width * [0-255]
       srl  r1,8                       ; (width * [0-255]) / 256
       mov  r1,r0                      ; copy result back
       .endproc
*// rand_max

*********************************************************************
*
* Generate a pseudo random number
*
* On return R0 contains the number, which is also stored at @RANDNO
*
* r0 and r1 are modified
*
rand:
       li   r0,28643                   ; A prime number to multiply by
       mpy  @rand_no,r0                ; Multiply by last random number
       ai   r1,31873                   ; Add a prime number
       src  r1,7                       ; Mix up the number to break odd/even pattern
       mov  r1,@rand_no                ; Save this number for next time
       mov  r1,r0
       rt
*// rand

*********************************************************************
*
* Display initial screen
*
* If sprites beyond 0-7 are to be used on a real 9918A VDP we need to update
* the second and third part of the pattern table as well (with the same 
* patterns). The color table is always OK at >800 bytes. See GMODE.
*
* Note that the pattern frame that should be uploaded here depends on the 
* initial direction of the scrolling. If you want to start at the bottom 
* you should start at frame 7 or 15, to allow enouh frames for building 
* the next name table. This means that the address PSTRIP+7 should be used
* instead of PSTRIP, and @SCRLY should be initilized so that the 3 least 
* significant bits are all ones, e.g. 511 - not 512.
*
initial_screen:
       .proc
*      Upload patterns
;       LI   R0,PTRNTB                  ; Destination address in VDP RAM
;       LI   R1,PSTRIP+7                ; Address of first scrolled pattern frame
;       MOV  @TCHNUM,R2                 ; Number of patterns of 8 bytes
;       BL   @VM8BW8                    ; Call copying routine
       li   r0,pattern_table+>400      ; destination address in vdp ram
       li   r1,PSTRIP+7                ; address of first scrolled pattern frame
       mov  @tchnum,r2                 ; number of patterns of 8 bytes
       bl   @vm8bw8                    ; call copying routine
*       Upload 2nd and 3rd part of the pattern table
*       LI   R0,PTRNT1                  ; Destination address in VDP RAM
*       LI   R1,PSTRIP                  ; Address of first scrolled pattern frame
*       MOV  @TCHNUM,R2                 ; Number of patterns of 8 bytes
*       BL   @VM8BW8                    ; Call copying routine
*       LI   R0,PTRNT2                  ; Destination address in VDP RAM
*       LI   R1,PSTRIP                  ; Address of first scrolled pattern frame
*       MOV  @TCHNUM,R2                 ; Number of patterns of 8 bytes
*       BL   @VM8BW8                    ; Call copying routine
*       Upload colors
;       LI   R0,COLRTB                  ; Destination address in VDP RAM
;       LI   R1,CSTRIP+7                ; Address of first scrolled color frame
;       MOV  @TCHNUM,R2                 ; Number of pattern colors of 8 bytes
;       BL   @VM8BW8                    ; Call copying routine
       LI   R0,color_table+>400        ; Destination address in VDP RAM
       li   r1,CSTRIP+7                ; address of first scrolled color frame
       mov  @tchnum,r2                 ; number of pattern colors of 8 bytes
       bl   @vm8bw8                    ; call copying routine
*      Init name tables
       mov  @scroll_y,r4               ; get initial scroll offset in pixels
       srl  r4,3                       ; convert to row offset
       mov  r4,r5
       sla  r4,5                       ; convert to name table offset
       mpy  @MS0,r5                    ; convert to map offset in r6
*      Table 0
       li   r0,name_table_0
       li   r1,>2800
       li   r2,>300
       bl   @vsmw
       li   r0,name_table_0+8          ; destination address in vdp ram
       li   r1,md0                     ; base address of map data
       a    r6,r1                      ; add map offset
       li   r7,24                      ; number of rows
inisc1:
       bl   @copy_row
       ai   r0,32
       dec  r7
       jne  inisc1
*      Table 1
       li   r0,name_table_1
       li   r1,>a800
       li   r2,>300
       bl   @vsmw
       li   r0,name_table_1+8          ; destination address in vdp ram
       li   r1,MD0                     ; base address of map data
       a    r6,r1                      ; add map offset
       li   r7,24                      ; number of rows
inisc2:
       bl   @copy_row_hi
       ai   r0,32
       dec  r7
       jne  inisc2
*      Table 2
       li   r0,name_table_2
       li   r1,>2800
       li   r2,>300
       bl   @vsmw
*      Table 3
       li   r0,name_table_3
       li   r1,>a800
       li   r2,>300
       bl   @vsmw
       .endproc
*// initial_screen

*********************************************************************
*
* Wait for vsync
*
* Modifies R0
*
vsync:
       movb @vdpsta,r0                 ; clear flag if already set
vsync1:
       movb @vdpsta,r0
       andi r0,>8000                   ; check interrupt flag
       jeq  vsync1                     ; loop until set
       b    *r11
*// vsync

*********************************************************************
*
* Set name table
*
* Altenate between tables 0 and 1 in frames 0-7
* Alternate between tables 2 and 3 in frames 8-15
*
* Tables 0 and 2 contain 'names' from the low character set (0-127)
* Tables 1 and 3 contain 'names' from the high character set (128-255)
*
* Note that if we have fixed the location of the names tables
* we could also calculate the value of register 3 instead of using
* 'if' statements, e.g.:
* reg3 = >0A + f & 8 >> 2 + f & 1
* for name tables >0A - >0C.
* 
* Modifies R0
*
set_name_table:
       .proc
       MOV  @scroll_frame,R0           ; Get scroll frame (0-15)
       coc  @eight,r0                  ; check which table set to use
       jeq  setnt2
       coc  @one,r0                    ; check which table to use
       jeq  setnt1
       li   r0,>020a                   ; namet0
       jmp  setnt4
setnt1:
       li   r0,>020b                   ; namet1
       jmp  setnt4
setnt2:
       coc  @one,r0                    ; check which table to use
       jeq  setnt3
       li   r0,>020c                   ; namet2
       jmp  setnt4
setnt3:
       li   r0,>020d                   ; namet3
*      update register 3
setnt4:
       bl   @vwtr
       .endproc
*// set_name_table

*********************************************************************
*
* Update pattern and color tables
*
* Alternate between updating low (0-127) or high (128-255) half of
* the character set. The set that is updated is not used (and therefore
* not visible) in the currently displayed name table. This provides the
* desired double buffering effect.
*
* Magellan is exporting the patterns and colors in strips of 16 bytes,
* each strip representing the transition between two original characters.
* In terms of the Transition Character Pairs table it's the 'to' character
* (pattern or color) followed by the 'from' character (pattern or color). 
*
* If sprites beyond 0-7 are to be used on a real 9918A VDP we need to update
* the second and third part of the pattern table as well (with the same 
* patterns). The color table is always OK at >800 bytes. See GMODE.
* 
* Modifies R0-R4
*
update_pattern_table:
       .proc
       MOV  @scroll_frame,R3           ; Read scroll frame (0-15) into register
*      Calculate VDP RAM destination address
       coc  @one,r3                    ; check which character set to update
       jeq  updpt1
       li   r0,pattern_table+>400      ; update high character set (128-255)
       jmp  updpt2
updpt1:
       li   r0,pattern_table           ; update low character set (128-255)
*      calculate cpu ram source address
updpt2:
       mov  r3,r1                      ; start with scroll frame
       a    @scroll_dy,r1              ; add direction (1 or -1)
       andi r1,>0007                   ; mod 8
       ai   r1,pstrip                  ; add base address of pattern strips
*      save calculated values
       mov  r0,r4
       mov  r1,r5
*      copy paterns
       mov  @tchnum,r2                 ; number of patterns
       bl   @vm8bw8
*      update 2nd and 3rd part of the pattern table
*       mov   r4,r0
*       ai    r0,>800
*       mov   r5,r1
*       mov   @tchnum,r2               ; number of patterns
*       bl    @vm8bw8
*       mov   r4,r0
*       ai    r0,>1000
*       mov   r5,r1
*       mov   @tchnum,r2               ; number of patterns
*       bl    @vm8bw8
*      copy colors
       mov  r4,r0
       ai   r0,color_table
       mov  r5,r1
       ai   r1,cstrip-pstrip           ; add offset betweem patterns and colors
       mov  @tchnum,r2                 ; number of patterns
       bl   @vm8bw8
       .endproc
*// update_pattern_table

*********************************************************************
*
* Update name table off-screen buffer
*
* The prepared buffers have a one row (8 pixels) offset from
* from the currently visible buffers, allowing a smooth transition
* after we have scrolled 7 pixels.
*
* We altenate between updating table buffers 2 and 3 in frames 0-7
* We alternate between updating table buffers 0 and 1 in frames 8-15
*
* Since we have 8 frames to update two buffers we need to update
* 1/4 buffer each frame, i.e. 6 screen rows. First frame we update 
* rows 0-5 of the first buffer. Second frame we update the same 6 
* rows of the second buffer, but this time we set the most significant
* bit to use the high character set. Third frame we update rows 6-11 
* of the first buffer, and so on.
*
* Note: As for SETNT we could also calculate the buffer number
* instead of using 'if' statements.
* 
* Modifies R0-R4
*
update_name_table:
       .proc
       MOV  @scroll_frame,R3           ; Get scroll frame (0-15)
*      Calculate row offset to the 1/4 of the buffer to update
       mov  r3,r0                      ; start with frame number
       andi r0,>0006                   ; transform to sequence: 0,0,2,2,4,4,6,6...
       mov  r0,r2                      ; copy to r2
       sla  r0,1                       ; multiply by 2
       a    r0,r2                      ; add to r2 to multiply by 6 and get
*                                      ; row offset: 0,0,6,6,12,12,18,18...
       mov  r2,r0                      ; copy back into r0 for later
*      Calculate map source address in R1
       mov  @scroll_y,r1               ; get scroll offset in pixels
       srl  r1,3                       ; divide by 8 to get row offset
       a    @scroll_dy,r1              ; add dy: prepared buffer has a 1 row offset
       a    r2,r1                      ; add the row offset we calculated before
       mpy  @ms0,r1                    ; multiply by map width to get character offset in r2
       li   r1,md0                     ; get the map base address
       a    r2,r1                      ; add the character offset
*      calculate buffer destination address in r0
       sla  r0,5                       ; convert row offset to chcracter offset
*      decide which buffer to update
       coc  @eight,r3                  ; bit weight >08 determines the group
       jne  updnt2                     ; if not set we update buffer 2 or 3
       coc  @one,r3                    ; bit weight >01 determines the buffer
       jeq  updnt1
       ai   r0,name_table_0+8          ; add base address to character offset
       jmp  updnt4
updnt1:
       ai   r0,name_table_1+8          ; add base address to character offset
       jmp  updnt4
updnt2:
       coc  @one,r3                    ; bit weight >01 determines the buffer
       jeq  updnt3
       ai   r0,name_table_2+8          ; add base address to character offset
       jmp  updnt4
updnt3:
       ai   r0,name_table_3+8          ; add base address to character offset
*      copy to vdp ram buffer
updnt4:
       li   r4,6                       ; number of rows to copy
       coc  @one,r3                    ; high or low character set copy?
       jeq  updnt6
updnt5:
       bl   @copy_row                  ; low character set
       ai   r0,32
       dec  r4
       jne  updnt5
       jmp  updnt7
updnt6:
       bl   @copy_row_hi
       ai   r0,32
       dec  r4
       jne  updnt6
*      return
updnt7:
       .endproc
*// update_name_table

*********************************************************************
*
* Update full name table off-screen buffers
*
* If the direction of scrolling, @SCRLDY, is changed in the middle of
* a frame cycle, the part of the off-screen buffers that has already 
* been prepared will become invalid. When scrolling up it should be safe
* to change direction (to down) in frames 0 and 8, and when scrolling 
* down it should be safe to change direction (to up) in frames 7 and 15.
* Otherwise this routine should be called.
*
* This implementation is simply calling the incremental update routine,
* UPDNT, 8 times. It could be done more efficient, but code reusing is
* also a virtue.
*
* Modifies R0-R4
*
update_full_name_table:
       .proc
       mov  @scroll_frame,r3
       .push r3                        ; push current scroll frame onto the stack
       andi r3,>0008                   ; move to beginning of frame cycle (0 or 8)
       mov  r3,@scroll_frame
upntf1:
       bl   @update_name_table         ; call the incremental update routine
       inc  @scroll_frame              ; next scroll frame
       mov  @scroll_frame,r3
       andi r3,>0007                   ; check for end of cycle
       jne  upntf1
*      return
       dect r10                        ; pop scroll frame off the stack
       mov  *r10,@scroll_frame
       .endproc
*// update_full_name_table

*********************************************************************
*
* Set graphics mode
*
graphics_mode:
       .proc
       clr  r0
       li   r1,vdp_registers
       li   r2,8
graphics_mode_1:
       movb *r1+,@r0lb
       bl   @vwtr                      ; Set register
       ai   r0,>0100
       dec  r2
       jne  graphics_mode_1
*      Clear VDP RAM
       clr  r0
       clr  r1
       li   r2,>4000
       bl   @vsmw
*      Disable sprites
       li   r0,sprite_attr_table
       li   r1,>d000
       bl   @vsbw
       .endproc
*      VDP registers
vdp_registers:
       byte >02                        ; Graphics II mode
       byte >c2                        ; 16K, display on, no interrupt
       byte name_table_0/>400          ; Name table
       byte >9f                        ; Color table
       byte pattern_table/>800+>00     ; Pattern table
       byte sprite_attr_table/>80      ; Sprite attribute table
       byte sprite_pattern_table/>800  ; Sprite pattern table
       byte >07                        ; Backdrop color
*// graphics_mode

*********************************************************************
*
* Copy one row of the map (22 bytes) to VDP
*
copy_row:
       .proc
       bl   @vwad
       li   r3,2                       ; 2 * 11
copy_row_1:
       movb *r1+,*r15                  ; Copy 11 bytes
       movb *r1+,*r15
       movb *r1+,*r15
       movb *r1+,*r15
       movb *r1+,*r15
       movb *r1+,*r15
       movb *r1+,*r15
       movb *r1+,*r15
       movb *r1+,*r15
       movb *r1+,*r15
       movb *r1+,*r15
       dec  r3
       jne copy_row_1
       .endproc
*// copy_row

*********************************************************************
*
* Copy one row of the map (22 bytes) to VDP,
* setting the most significant bit of each byte written.
*
copy_row_hi:
       .proc
       bl   @vwad
       li   r3,3                       ; 3 * 8 - 2
       jmp  copy_row_hi_2              ; First time only copy 6 bytes
copy_row_hi_1:
       mov  *r1+,r2
       ori  r2,>8080
       movb r2,*r15                    ; Byte 1
       movb @r2lb,*r15                 ; Byte 2
copy_row_hi_2:
       mov  *r1+,r2
       ori  r2,>8080
       movb r2,*r15                    ; Byte 3
       movb @r2lb,*r15                 ; Byte 4
       mov  *r1+,r2
       ori  r2,>8080
       movb r2,*r15                    ; Byte 5
       movb @r2lb,*r15                 ; Byte 6
       mov  *r1+,r2
       ori  r2,>8080
       movb r2,*r15                    ; Byte 7
       movb @r2lb,*r15                 ; Byte 8
       dec  r3
       jne copy_row_hi_1
       .endproc
*// copy_row_hi

*********************************************************************
*
* VDP Multiple 8 Byte Write
*
* This routine (or just the inner loop) can be moved into scratchpad
* memory for a performance boost of about 10%.
*
* R0: Starting write address in VDP RAM
* R1: Starting read address in CPU RAM
* R2: Number of groups of 8 bytes to send to the VDP RAM
* R3: Number of bytes to skip after reading 8 bytes 
*
* R0 is modified, R1 is next read address, R2 is zero
*
vm8bw8:
       li   r3,8                       ; call here to skip 8 bytes
       jmp  vm8bw0
vm8bw:
       clr  r3                         ; call here to skip zero bytes
vm8bw0:
       .proc
       bl   @vwad                      ; setup write address
       li   r0,vdpwd                   ; load vdp write data address into register
vm8bw1:
       movb *r1+,*r0                   ; write byte to vdp ram
       movb *r1+,*r0                   ; repeat 2
       movb *r1+,*r0                   ; repeat 3
       movb *r1+,*r0                   ; repeat 4
       movb *r1+,*r0                   ; repeat 5
       movb *r1+,*r0                   ; repeat 6
       movb *r1+,*r0                   ; repeat 7
       movb *r1+,*r0                   ; repeat 8 times
       a    r3,r1                      ; skip source bytes
       dec  r2                         ; group counter
       jne  vm8bw1                     ; loop if not done
       .endproc
*// vm8bw

*********************************************************************
*
* VDP Multiple 8 Byte High Write
*
* Like VM8BW but sets the most significant bit of each byte written.
* Note: only works correctly for even read addresses.
*
* R0: Starting write address in VDP RAM
* R1: Starting read address in CPU RAM (must be even)
* R2: Number of groups of 8 bytes to send to the VDP RAM
*
* R0 is modified, R1 is next read address, R2 is zero, R3 is modified
*
vm8bhw:
       .proc
       bl   @vwad                      ; setup write address
       li   r3,vdpwd                   ; load vdp write data address into register
vm8bh1:
       mov  *r1+,r0                    ; read word from cpu ram
       ori  r0,>8080                   ; set most significant bits
       movb r0,*r3                     ; send msb to vdp
       movb @r0lb,*r3                  ; send lsb to vdp
       mov  *r1+,r0                    ; repeat 2
       ori  r0,>8080                   ;
       movb r0,*r3                     ;
       movb @r0lb,*r3                  ;
       mov  *r1+,r0                    ; repeat 3
       ori  r0,>8080                   ;
       movb r0,*r3                     ;
       movb @r0lb,*r3                  ;
       mov  *r1+,r0                    ; repeat 4 times
       ori  r0,>8080                   ;
       movb r0,*r3                     ;
       movb @r0lb,*r3                  ;
       dec  r2                         ; group counter
       jne  vm8bh1                     ; loop if not done
       .endproc
*// vm8bhw

*********************************************************************
*
*       Includes
*
       copy "vdp.a99"

*********************************************************************
*
*       Data
*
       copy "graphics.a99"
       copy "map-animations.a99"

windows:
       data 177,4,0,14
       data 179,3,1,1
       data 180,3,0,7
       data 183,5,0,0
windows_2nd_last:
       data 184,2,0,2
windows_last:
       data 186,0,0,0
       data -1
byte_closed:
       byte >00
byte_open:
       byte >36

       end  start
