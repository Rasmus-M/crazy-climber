*********************************************************************
*
* Crazy climber
*
* Rasmus Moustgaard <rasmus.moustgaard@gmail.com>
*
*********************************************************************

       def   start

       copy "macros.a99"
       copy "sound-defs.a99"
       copy "speech-defs.a99"

**
* Memory mapped addresses
*
vdpwd:                                 ; VDP write data
       equ  >8c00
vdpwa:                                 ; VDP set read/write address
       equ  >8c02
vdprd:                                 ; VDP read data
       equ  >8800
vdpsta:                                ; VDP status
       equ  >8802
sound:                                 ; Sound
       equ  >8400
spchwt:
       equ  >9400
spchrd:
       equ  >9000


*       VPD RAM Map
pattern_table:                         ; Pattern table base
       equ  >0000
pattern_table_1:                       ; Pattern table part 2
       equ  >0800
pattern_table_2:                       ; Pattern table part 3
       equ  >1000
sprite_pattern_table:                  ; Sprite pattern table
       equ  >1800
color_table:                           ; Color table base
       equ  >2000
name_table_0:                          ; Name table base 0 (>0A)
       equ  >2800
name_table_1:                          ; Name table base 1 (>0B)
       equ  >2C00
sprite_attr_table:                     ; Sprite attribute table
       equ  >3700

*      Constants
map_width:
       equ  22
scroll_max:
       equ  >0bf8
n_windows:
       equ  12
n_sprites:
       equ  16
attenuation_during_speech:
       equ  6

**
* Scratch pad
*
pad:
       equ  >8300
wrksp:
       equ  pad                        ; Workspace
r0lb:
       equ  wrksp+1
r1lb:
       equ  wrksp+3
r2lb:
       equ  wrksp+5
r3lb:
       equ  wrksp+7
wrksp2:
       equ  wrksp+>20
stack:
       equ  wrksp2+>20
**
* PAD constants
*
padcon:
       equ  stack+>16                  ; Start of pad constants
one:
       equ  padcon
two:
       equ  padcon+2
**
* PAD variables
*
padvar:                                ; Start of pad variables
       equ  two+2
*********************************************************************
*
* Variables and data
*
rand_no:                               ; Random number seed
       equ  padvar
vdp_status:                            ; VDP status byte
       equ  rand_no+2
frame:                                 ; Frame counter
       equ  vdp_status+2
scroll_y:                              ; Vertical scroll offset
       equ  frame+2
scroll_dy:                             ; Scroll direction
       equ  scroll_y+2
climber_pos:                           ; Climber y/x position in screen coordinates
       equ  scroll_dy+2
left_anim_ptr:                         ; Left animation pointer
       equ  climber_pos+2
right_anim_ptr:                        ; Right animation pointer
       equ  left_anim_ptr+2
left_ascending:                        ; Flag: ascending on left side?
       equ  right_anim_ptr+2
right_ascending:                       ; Flag: ascending on right side?
       equ  left_ascending+2
left_grip:                             ; Flag: left hand is placed on bottom of window
       equ  right_ascending+2
right_grip:                            ; Flag: right hand is placed on bottom of window
       equ  left_grip+2
left_hand_pos:                         ; Left hand position: -1=window right, 0=wall or no grip, 1=window left
       equ  right_grip+2
right_hand_pos:                        ; Right hand position: 1=window right, 0=wall or no grip, -1=window left
       equ  left_hand_pos+2
left_wide:                             ; Flag: wide on left side?
       equ  right_hand_pos+2
right_wide:                            ; Flag: wide on right side?
       equ  left_wide+2
animation_count:                       ; Number of frames to repeat last animation frame
       equ  right_wide+2
animation_changed:                     ; Flag: did animation frame (left or right) change?
       equ  animation_count+2
windows_head_ptr:                      ; Head of window animation list
       equ  animation_changed+2
windows_tail_ptr:                      ; Head of window animation list
       equ  windows_head_ptr+2
snd_channel_1:
       equ  windows_tail_ptr+2
snd_channel_2:
       equ  snd_channel_1+snd_channel_size
snd_channel_3:
       equ  snd_channel_2+snd_channel_size
snd_channel_4:
       equ  snd_channel_3+snd_channel_size
snd_track_1:
       equ  snd_channel_4+snd_channel_size
snd_track_2:
       equ  snd_track_1+snd_track_size
snd_track_3:
       equ  snd_track_2+snd_track_size
module_speed:
       equ  snd_track_3+snd_track_size
speech_detected:
       equ  module_speed+2
speech_status:
       equ  speech_detected+2
speech_addr:
       equ  speech_status+2
speech_counter:
       equ  speech_addr+2
speech_read_pad:
       equ  speech_counter+2
vm8bw_pad:
       equ  speech_read_pad+14
pad_max:                               ; Max scratchpad address used
       equ  vm8bw_pad+24

********************************************************************************
*
* Main program
*
       aorg >2000

start  limi 0                          ; disable interrupts
       lwpi wrksp                      ; setup workspace
       li   r10,stack                  ; use r10 as stack pointer
       bl   @one_time_init
*      Display initial screen
       li   r0,scroll_max              ; start at the bottom of the map
       mov  r0,@scroll_y
       bl   @initial_screen
*      Intro climb
       bl   @intro_climb
*      Init variables for main loop
       li   r0,>5da8
       mov  r0,@climber_pos
       li   r0,left_anim
       mov  r0,@left_anim_ptr
       clr  @left_wide
       bl   @update_climber_attrs_left
       li   r0,right_anim
       mov  r0,@right_anim_ptr
       clr  @right_wide
       bl   @update_climber_attrs_right
       clr  @scroll_dy
       clr  @frame
*      Main loop
main_loop:
*      Wait for vsync
       bl   @vsync
*      Set name table
       bl   @set_name_table
*      Music and speech
       bl   @int_routine
*      Display sprites
       bl   @display_sprites
*      Control climber
       bl   @check_grip
       bl   @control_climber_vert
       bl   @control_climber_horz
       bl   @check_int
*      Change scroll offset
       bl   @change_scroll_offset
*      Animate windows and faces
       bl   @animate_windows
       bl   @check_int
       bl   @create_windows
*      Update patterns
       bl   @update_pattern_table
*      Update name table buffer
       bl   @update_name_table
*      Loop forever
       inc  @frame
       jmp  main_loop
*// main_loop

*********************************************************************
*
* Wait for vsync
*
vsync:
       movb @vdpsta,@vdp_status        ; Clear flag if already set
       clr  r12
vsync1:
       tb   2
       jeq  vsync1
       socb @vdpsta,@vdp_status
       b    *r11
*// vsync

*********************************************************************
*
* Test for interrupt and execute interrupt routine if found
*
check_int:
       clr  r12
       tb   2
       jeq  check_int_1
       movb @vdpsta,@vdp_status
       .proc
       bl   @int_routine
       .endproc
check_int_1:
       b    *r11
*// check_int



*********************************************************************
*
* Interrupt routine
*
int_routine:
       lwpi wrksp2
       mov  @wrksp+20,r10
       bl   @module_player
       bl   @speech_player
       lwpi wrksp
       rt
*// int_routine

*********************************************************************
*
* Set name table
*
* Altenate between tables 0 and 1
*
* Tables 0 contain 'names' from the low character set (0-127)
* Tables 1 contain 'names' from the high character set (128-255)
*
* Modifies r0
*
set_name_table:
       .proc
       mov  @frame,r0                  ; Get frame
       andi r0,1
       ai   r0,>020a
       bl   @vwtr
       .endproc
*// set_name_table

*********************************************************************
*
* Display sprites
*
display_sprites:
       .proc
       li   r0,sprite_attr_table
       bl   @vwad
       bl   @display_climber_sprites
       bl   @handle_other_sprites
       li   r1,>d000                   ; Write end marker
       movb r1,*r15
       .endproc
*// display_sprites

*********************************************************************
*
* Update pattern and color tables
*
* Alternate between updating low (0-127) or high (128-255) half of
* the character set. The set that is updated is not used (and therefore
* not visible) in the currently displayed name table. This provides the
* desired double buffering effect.
*
* Modifies R0-R4
*
update_pattern_table:
       .proc
       bl   @check_int
*      Calculate VDP RAM destination address
       mov  @frame,r0                  ; Read frame into register
       inv  r0
       andi r0,1
       sla  r0,10                      ; 0 or >400
       ai   r0,pattern_table
*      Calculate cpu ram source address
       mov  @scroll_y,r1               ; scroll offset
       andi r1,>0007                   ; mod 8
       ai   r1,pstrip                  ; add base address of pattern strips
*      Save calculated values
       mov  r0,r4
       mov  r1,r5
*      Copy patterns 1st part
       mov  @tchnum,r2                 ; number of patterns
       bl   @vm8bw8
       bl   @check_int
*      Copy patterns 2nd part
       mov   r4,r0
       ai    r0,>800
       mov   r5,r1
       mov   @tchnum,r2                ; number of patterns
       bl    @vm8bw8
       bl   @check_int
*      Copy patterns 3rd part
       mov   r4,r0
       ai    r0,>1000
       mov   r5,r1
       mov   @tchnum,r2                ; number of patterns
       bl    @vm8bw8
       bl   @check_int
*      Copy colors
       mov  r4,r0
       ai   r0,color_table
       mov  r5,r1
       ai   r1,cstrip-pstrip           ; add offset betweem patterns and colors
       mov  @tchnum,r2                 ; number of patterns
       bl   @vm8bw8
       bl   @check_int
       .endproc
*// update_pattern_table

*********************************************************************
*
* Update name table off-screen buffer
*
* Modifies R0-R4
*
update_name_table:
       .proc
*      Calculate map source address in r1
       mov  @scroll_y,r1               ; get scroll offset in pixels
       srl  r1,3                       ; divide by 8 to get row offset
       mpy  @ms0,r1                    ; multiply by map width to get character offset in r2
       li   r1,md0                     ; get the map base address
       a    r2,r1                      ; add the character offset
       li   r4,24                      ; number of rows to copy
*      Decide which buffer to update
       mov  @frame,r0                  ; Read frame into register
       andi r0,1
       jeq  update_name_table_2
*      Copy to vdp ram buffer
       li   r0,name_table_0+8          ; VDP address
update_name_table_1:
       bl   @copy_row                  ; low character set
       ai   r0,32
       dec  r4
       jne  update_name_table_1
       jmp  update_name_table_4
update_name_table_2:
       li   r0,name_table_1+8          ; VDP address
update_name_table_3:
       bl   @copy_row_hi
       ai   r0,32
       dec  r4
       jne  update_name_table_3
       bl   @check_int
update_name_table_4:
       .endproc
*// update_name_table

*********************************************************************
*
* Change scroll offset
*
change_scroll_offset:
       a    @scroll_dy,@scroll_y
       mov  @scroll_y,r0
       ci   r0,scroll_max
       jle  change_scroll_offset_1
       li   r0,scroll_max
       mov  r0,@scroll_y
change_scroll_offset_1:
       rt
*// change_scroll_offset

*********************************************************************
*
* Animate windows
*
animate_windows:
       .proc
       mov  @frame,r0                  ; Only do this every 4th frame
       andi r0,>0003
       jne  animate_windows_8
       mov  @windows_head_ptr,r3       ; List of window animations (including resident faces)
animate_windows_1:
       mov  r3,r3
       jeq  animate_windows_8          ; zero terminates
       mov  *r3+,r1                    ; Window y (row)
       mov  *r3+,r0                    ; Window x (0 - 5)
       bl   @window_map_addr           ; Map address in r2
       mov  *r3+,r5                    ; Get animation type
       mov  *r3,r4                     ; Get animation frame
       sla  r4,1                       ; To word offset
       ci   r5,window_anim_type_resident ; Is it a face animation?
       jne  animate_windows_3          ; No - move on
       ai   r4,face_appear             ; Yes - add base address of face animations
       jmp  animate_windows_5
animate_windows_3:
       cb   @-map_width(r2),@b_window_closed_tch  ; Is window above closed?
       jeq  animate_windows_4          ; Yes - move on
       ai   r4,close_window_below_open ; No - add base address of closing windows below open animation
       jmp  animate_windows_5
animate_windows_4:
       ai   r4,close_window_below_closed ; Add base address of closing windows below closed animation
animate_windows_5:
       mov  *r4,r4                     ; Get address of animation bytes
       movb *r4+,*r2+                  ; Top row
       movb *r4+,*r2
       ai   r2,map_width-1             ; Next row
       movb *r4+,*r2+                  ; Middle row
       movb *r4+,*r2
       ai   r2,map_width-1             ; Next row
       movb *r4+,*r2+                  ; Bottom row
       movb *r4+,*r2
*      Update animation frame
       mov  *r3,r4                     ; Get animation frame
       inc  r4                         ; Increment animation frame
       mov  r4,*r3                     ; Write frame back
       ai   r3,-window_anim_frame      ; Back to base of record
       ci   r5,window_anim_type_resident ; Is it a face animation?
       jeq  animate_windows_6
*      Window animation
       ci   r4,32                      ; End at 32
       jeq  animate_windows_7
       jmp  animate_windows_2          ; Next window
*      Face animation
animate_windows_6:
       ci   r4,16                      ; End at 16
       jeq  animate_windows_7
       ci   r4,4                       ; Is it frame 4?
       jne  animate_windows_2          ; No - next window
       bl   @create_resident           ; Create a new resident sprite
       jmp  animate_windows_2          ; Next window
*      Teminate animation
animate_windows_7:
       bl   @remove_window_from_list
*      Next
animate_windows_2:
       mov  @window_anim_next(r3),r3   ; Next window
       jmp  animate_windows_1
animate_windows_8:
       .endproc
*// animate_windows

*********************************************************************
*
* Remove window animation in r3 from list
*
* Modifies r1,r2
*
remove_window_from_list:
       clr  @window_anim_row(r3)       ; Clear y coord to mark as available
       mov  @window_anim_prev(r3),r1   ; Get previous
       mov  @window_anim_next(r3),r2   ; Get next
       jne  remove_window_from_list_1  ; Removing last? No - skip ahead
*      Removing last
       mov  r1,@windows_tail_ptr       ; tail = previous
       jeq  remove_window_from_list_2  ; Skip ahead if also first
       clr  @window_anim_next(r1)      ; previous.next = null
       jmp  remove_window_from_list_3  ; Return
remove_window_from_list_1:
*      Not last
       mov  r1,@window_anim_prev(r2)   ; next.previous = previous
       jeq  remove_window_from_list_2  ; Jump if first
*      Not first or last
       mov  r2,@window_anim_next(r1)   ; previous.next = next
       jmp  remove_window_from_list_3  ; Return
*      Removing first
remove_window_from_list_2:
       mov  r2,@windows_head_ptr       ; head = next
       jeq  remove_window_from_list_3  ; Return if last
       clr  @window_anim_prev(r2)      ; next.previous = null
remove_window_from_list_3:
       rt
*// remove_window_from_list

*********************************************************************
*
* Add window animation in r3 to list
*
* Modifies r1,r2
*
add_window_to_list:
       mov  @windows_head_ptr,r2       ; current = head
       jne  add_window_to_list_2
*      Add to empty list
       mov  r3,@windows_tail_ptr       ; tail = new
       clr  @window_anim_next(r3)      ; new.next = null
add_window_to_list_1:
*      Add first
       mov  r3,@windows_head_ptr       ; head = new
       clr  @window_anim_prev(r3)      ; new.previous = null
       jmp  add_window_to_list_5       ; Done
*      Not empty list
add_window_to_list_2:
       mov  r2,r2                      ; End of list?
       jeq  add_window_to_list_4       ; Yes - add at end
       c    *r3,*r2                    ; Compare y (window_anim_row) values
       jh   add_window_to_list_3       ; Still higher - proceed to next
*      Add in the middle or first      ; current.y >= new.y
       mov  r2,@window_anim_next(r3)   ; new.next = current
       mov  @window_anim_prev(r2),r1   ; previous = current.previous
       mov  r3,@window_anim_prev(r2)   ; current.previous = new
       mov  r1,r1                      ; previous == null?
       jeq  add_window_to_list_1       ; If null then adding first
       mov  r3,@window_anim_next(r1)   ; previous.next = new
       mov  r1,@window_anim_prev(r3)   ; new.previous = previous
       jmp  add_window_to_list_5       ; Done
add_window_to_list_3:
       mov  @window_anim_next(r2),r2   ; Next window
       jmp  add_window_to_list_2       ; Loop
*      Add at end
add_window_to_list_4:
       mov  @windows_tail_ptr,r2       ; tail
       mov  r3,@window_anim_next(r2)   ; tail.next = new
       mov  r2,@window_anim_prev(r3)   ; new.previous = tail
       clr  @window_anim_next(r3)      ; new.next = null
       mov  r3,@windows_tail_ptr       ; tail = new
add_window_to_list_5:
       rt
*// add_window_to_list

*********************************************************************
*
* Create window animations
*
create_windows:
       .proc
       mov  @frame,r0                  ; Only do this every 16th frame
       andi r0,>000f
       jne  create_windows_9
*      Remove window animations that are scrolled out
       mov  @scroll_y,r4
       srl  r4,4                       ; Number of windows scrolled
       ai   r4,12                      ; Y coord of bottom window row on screen
       mov  @windows_head_ptr,r3
create_windows_1:
       mov  r3,r3                      ; Reached the end?
       jeq  create_windows_3           ; Yes, move on
       c    r4,*r3                     ; Compare bottom row to window_anim_row
       jhe  create_windows_2           ; Skip ahead if bottom row is higher or equal
       bl   @remove_window_from_list   ; Bottom row is lower - remove window
create_windows_2:
       mov  @window_anim_next(r3),r3   ; Next window
       jmp  create_windows_1
create_windows_3:
*      Find an available slot to use
       li   r3,window_anims            ; Don't use linked list since we're looking for an empty slot
create_windows_4:
       mov  *r3,r1                     ; Window y (window_anim_row)
       jlt  create_windows_9           ; Negative is the end (no space)
       jeq  create_windows_5           ; Zero is unused
       ai   r3,window_anim_size
       jmp  create_windows_4
*      Add new window
create_windows_5:
       ai   r4,-12                     ; Y coord of top window row on screen
       li   r2,12                      ; Y coord between 0 and 11
       bl   @rand_max
       a    r4,r0                      ; Add y coord of top window row on screen
       mov  r0,*r3                     ; Save it in new window anim (window_anim_row)
       li   r2,6                       ; X coord between 0 and 5
       bl   @rand_max                  ; X coord in r0
       mov  r0,@window_anim_col(r3)    ; Write X coord
       mov  *r3,r1                     ; Y coord (window_anim_row)
*      Check map position
       bl   @window_map_addr           ; Window address in r2
       bl   @is_open_window            ; Is there an open window?
       jne  create_windows_8           ; If not then skip
       ai   r2,-2*map_width            ; Move one window up
       bl   @is_open_window_bottom     ; Is there an open window above?
       jne  create_windows_8           ; If not then skip
       ai   r2,4*map_width             ; Move one window down
       bl   @is_open_window            ; Is there an open window below?
       jne  create_windows_8           ; If not then skip
*      Set type
       mov  @scroll_y,r0
       ci   r0,>0a80
       jh   create_windows_6           ; No residents at the bottom
       bl   @rand
       andi r0,3                       ; 1/4 chance of resident
       ci   r0,window_anim_type_resident
       jeq  create_windows_7
create_windows_6:
       clr  r0                         ; window_anim_type_window
create_windows_7:
       mov  r0,@window_anim_type(r3)   ; 0 = empty window, 1 = resident
       clr  @window_anim_frame(r3)     ; Clear frame
*      Add new window to linked list sorted by y (row)
       bl   @add_window_to_list
       jmp  create_windows_9
create_windows_8:
*      Cancel adding window
       clr  *r3                        ; Make available again
create_windows_9:
       .endproc
*// create_windows

*********************************************************************
*
* Check grip
*
check_grip:
       .proc
       mov  @animation_count,r1        ; Is an animation count already taking place?
       jne  check_grip_3               ; Yes - return
*      Left
       clr  @left_grip
       clr  @left_hand_pos
       bl   @left_hand_y_offset
       mov  @scroll_y,r0
       ai   r0,-8
       a    r0,r1
       andi r1,>000f                   ; Hand position relative to building
       jne  check_grip_1
       bl   @left_hand_map_addr
       bl   @is_open_window_bottom
       jne  check_grip_1
       seto @left_grip
       bl   @left_hand_position
       mov  r1,@left_hand_pos
*      Right
check_grip_1:
       clr  @right_grip
       clr  @right_hand_pos
       bl   @right_hand_offset
       mov  @scroll_y,r0
       ai   r0,-8
       a    r0,r1
       andi r1,>000f                   ; Hand position relative to building
       jne  check_grip_2
       bl   @right_hand_map_addr
       bl   @is_open_window_bottom
       jne  check_grip_2
       seto @right_grip
       bl   @right_hand_position
       mov  r1,@right_hand_pos
*      Check if no grip
check_grip_2:
       mov  @left_grip,r0
       soc  @right_grip,r0
       jne  check_grip_3
*      No grip
       mov  @two,@animation_count      ; Animation count = 2
       mov  @two,@scroll_dy
check_grip_3:
       .endproc
*// check_grip

*********************************************************************
*
* Control climber vertically
*
control_climber_vert:
       .proc
       mov  @animation_count,r0        ; Is an animation count already taking place?
       jeq  control_climber_vert_1     ; Proceed if not
       b    @control_climber_vert_10   ; Branch to decrement counter
control_climber_vert_1:
       clr  @animation_changed
       clr  @scroll_dy
*      Left side
       mov  @left_anim_ptr,r3          ; Get animation pointer
*      Check for left grip
       abs  @left_grip                 ; Does hand have grip?
       jeq  control_climber_vert_2     ; Skip ahead if not
*      Left grip
       ci   r3,left_anim_last          ; Is it the last animation frame?
       jeq  control_climber_vert_2     ; Skip ahead if so
       li   r0,KEY_D                   ; Check down key
       bl   @check_key
       jeq  control_climber_vert_2     ; Move on if not pressed
       ai   r3,spr_anim_size           ; Next frame
       mov  r3,@left_anim_ptr          ; Save new pointer
       li   r0,-2                      ; Scroll down 2 pixels
       mov  r0,@scroll_dy
       bl   @play_left_climbing_sound
       jmp  control_climber_vert_4
*      Check for right grip
control_climber_vert_2:
       abs  @right_grip                ; Does other hand have grip?
       jeq  control_climber_vert_3     ; Skip ahead if not
*      Right grip
       ci   r3,left_anim_last          ; Is it the last animation frame?
       jeq  control_climber_vert_3     ; Skip ahead if so
       li   r0,KEY_D                   ; Check down key
       bl   @check_key
       jeq  control_climber_vert_3     ; Move on if not pressed
       ai   r3,spr_anim_size           ; Next frame
       mov  r3,@left_anim_ptr          ; Save new pointer
       jmp  control_climber_vert_4
*      Not right grip
control_climber_vert_3:
       ci   r3,left_anim               ; Is it the first animation frame?
       jeq  control_climber_vert_5     ; Skip ahead if so
       li   r0,KEY_E                   ; Check up key
       bl   @check_key
       jeq  control_climber_vert_5     ; Move on if not pressed
       ai   r3,-spr_anim_size          ; Previous frame
       mov  r3,@left_anim_ptr          ; Save new pointer
control_climber_vert_4:
       bl   @update_climber_attrs_left
       mov  @two,@animation_count      ; Animation count = 2
       seto @animation_changed
*      Right
control_climber_vert_5:
       mov  @right_anim_ptr,r3          ; Get animation pointer
*      Check for right grip
       abs  @right_grip                ; Does hand have grip?
       jeq  control_climber_vert_6     ; Skip ahead if not
*      Right grip
       ci   r3,right_anim_last         ; Is it the last animation frame?
       jeq  control_climber_vert_6     ; Skip ahead if so
       li   r0,KEY_K                   ; Check down key
       bl   @check_key
       jeq  control_climber_vert_6     ; Move on if not pressed
       ai   r3,spr_anim_size           ; Next frame
       mov  r3,@right_anim_ptr         ; Save new pointer
       li   r0,-2                      ; Scroll down 2 pixels
       mov  r0,@scroll_dy
       bl   @play_right_climbing_sound
       jmp  control_climber_vert_8
*      Check for right grip
control_climber_vert_6:
       abs  @left_grip                 ; Does other hand have grip?
       jeq  control_climber_vert_7     ; Skip ahead if not
*      Left grip
       ci   r3,right_anim_last         ; Is it the last animation frame?
       jeq  control_climber_vert_7     ; Skip ahead if so
       li   r0,KEY_K                   ; Check down key
       bl   @check_key
       jeq  control_climber_vert_7     ; Move on if not pressed
       ai   r3,spr_anim_size           ; Next frame
       mov  r3,@right_anim_ptr         ; Save new pointer
       jmp  control_climber_vert_8
*      Not left grip
control_climber_vert_7:
       ci   r3,right_anim              ; Is it the first animation frame?
       jeq  control_climber_vert_9     ; Skip ahead if so
       li   r0,KEY_I                   ; Check up key
       bl   @check_key
       jeq  control_climber_vert_9     ; Move on if not pressed
       ai   r3,-spr_anim_size          ; Previous frame
       mov  r3,@right_anim_ptr         ; Save new pointer
control_climber_vert_8:
       bl   @update_climber_attrs_right
       mov  @two,@animation_count      ; Animation count = 2
       seto @animation_changed
control_climber_vert_9:
       abs  @animation_changed
       jeq  control_climber_vert_11
control_climber_vert_10:
       dec  @animation_count
control_climber_vert_11:
       .endproc
*// control_climber_vert

*********************************************************************
*
* Play left climbing sound
*
play_left_climbing_sound:
       .proc
       mov  @left_anim_ptr,r0
       ci   r0,left_anim_1
       jeq  play_left_climbing_sound_1
       ci   r0,left_anim_3
       jne  play_left_climbing_sound_2
play_left_climbing_sound_1
       bl   @play_left_hand
play_left_climbing_sound_2
       .endproc
*// play_left_climbing_sound

*********************************************************************
*
* Play right climbing sound
*
play_right_climbing_sound:
       .proc
       mov  @right_anim_ptr,r0
       ci   r0,right_anim_1
       jeq  play_right_climbing_sound_1
       ci   r0,right_anim_3
       jne  play_right_climbing_sound_2
play_right_climbing_sound_1
       bl   @play_right_hand
play_right_climbing_sound_2
       .endproc
*// play_right_climbing_sound

*********************************************************************
*
* Update right climber attributes
*
update_climber_attrs_left:
*      Update patterns
       mov  @left_anim_ptr,r3
       mov  @left_wide,r0
       jeq  update_climber_attrs_left_1
       ai   r3,4                       ; Move to wide patterns
update_climber_attrs_left_1:
       mov  *r3+,r1                    ; Pointer to top/bottom body sprite patterns
       movb *r1+,@sprite_attributes_body+2
       movb *r1,@sprite_attributes_body+10
       mov  *r3,r1                     ; Pointer to head/hands sprite pattern
       movb *r1+,@sprite_attributes_head+10
       movb *r1,@sprite_attributes_head+2
*      Update position
       mov  @climber_pos,r0
       mov  r0,@sprite_attributes_head+8
       mov  r0,@sprite_attributes_body
       ai   r0,>1000
       mov  r0,@sprite_attributes_head
       mov  r0,@sprite_attributes_body+8
       rt
*// update_climber_attrs_left

*********************************************************************
*
* Update right climber attributes
*
update_climber_attrs_right:
*      Update patterns
       mov  @right_anim_ptr,r3
       mov  @right_wide,r0
       jeq  update_climber_attrs_right_1
       ai   r3,4                       ; Move to wide patterns
update_climber_attrs_right_1:
       mov  *r3+,r1                    ; Pointer to top/bottom body sprite patterns
       movb *r1+,@sprite_attributes_body+6
       movb *r1,@sprite_attributes_body+14
       mov  *r3,r1                     ; Pointer to head/hands sprite pattern
       movb *r1+,@sprite_attributes_head+14
       movb *r1,@sprite_attributes_head+6
*      Update position
       mov  @climber_pos,r0
       ai   r0,>0010
       mov  r0,@sprite_attributes_head+12
       mov  r0,@sprite_attributes_body+4
       ai   r0,>1000
       mov  r0,@sprite_attributes_head+4
       mov  r0,@sprite_attributes_body+12
       rt
*// update_climber_attrs_right

*********************************************************************
*
* Control climber horizontally
*
control_climber_horz:
       .proc
       mov  @animation_count,r0        ; Is an animation count already taking place?
       jeq  control_climber_check_keys
       b    @control_climber_horz_11   ; Skip ahead if so
*      Check keys
control_climber_check_keys:
       clr  r1                         ; Check if the left joystick is moved left
       li   r0,KEY_S
       bl   @check_key
       jeq  check_keys_1
       seto r1
check_keys_1:
       clr  r2                         ; Check if the left joystick is moved right
       li   r0,KEY_F
       bl   @check_key
       jeq  check_keys_2
       seto r2
check_keys_2:
       clr  r3                         ; Check if the right joystick is moved left
       li   r0,KEY_J
       bl   @check_key
       jeq  check_keys_3
       seto r3
check_keys_3:
       clr  r4                         ; Check if the right joystick is moved right
       li   r0,KEY_L
       bl   @check_key
       jeq  check_keys_4
       seto r4
check_keys_4:
*      Check for auto movement left
       abs  r1
       jeq  auto_move_3
       abs  r3
       jeq  auto_move_3
*      Auto move left
       mov  @left_hand_pos,r0
       jgt  auto_move_1
       jlt  auto_move_2
*      Left hand at wall
       mov  @right_hand_pos,r0
       jgt  control_climber_horz_0a    ; Right hand at left side of window - make left wide
       jeq  auto_move_0                ; Right hand at wall (falling)
       cb   @climber_pos+1,@b_building_left
       jh   control_climber_horz_1a    ; Right hand at right side of window - make right wide and move
auto_move_0:
       b    @control_climber_horz_11
auto_move_1:
*      Left hand at left side of window
       mov  @right_hand_pos,r0
       jgt  control_climber_horz_8a    ; Right hand at left side of window - make left normal and move
       jlt  control_climber_horz_0a    ; Right hand at right side of window - make left wide
       abs  @left_wide
       jne  control_climber_horz_8a    ; Make left normal and move
       abs  @right_wide
       jeq  control_climber_horz_5a    ; Right hand at wall, right normal - make right wide
       jmp  control_climber_horz_7a    ; Right hand at wall, right wide - make right normal
auto_move_2:
*      Left hand at right side of window
       mov  @right_hand_pos,r0
       jlt  control_climber_horz_8a    ; Right hand at right side of window - make left normal and move
       jeq  control_climber_horz_5a    ; Right hand at wall - make right wide (bad position)
       abs @left_wide
       jne  control_climber_horz_1a    ; Right hand at left side of window, left wide - make right wide and move
       jmp  control_climber_horz_0a    ; Right hand at left side of window, left normal - make left wide
auto_move_3:
*      Check for auto movement right
       abs  r2
       jeq  control_climber_horz_0
       abs r4
       jeq  control_climber_horz_0
*      Auto move right
       mov  @right_hand_pos,r0
       jgt  auto_move_4
       jlt  auto_move_5
*      Right hand at wall
       mov  @left_hand_pos,r0
       jlt  control_climber_horz_5a      ; Left hand at right side of window - make right wide
       jeq  control_climber_horz_11      ; Left hand at wall (falling)
       cb   @climber_pos+1,@b_building_right
       jl   control_climber_horz_6a      ; Left hand at left side of window - make left wide and move
       jmp  control_climber_horz_11
auto_move_4:
*      Right hand at left side of window
       mov  @left_hand_pos,r0
       jgt  control_climber_horz_3a      ; Left hand at left side of window - make right normal and move
       jeq  control_climber_horz_0a      ; Left hand at wall - make left wide (bad position)
       abs  @right_wide
       jne  control_climber_horz_6a      ; Left hand at right side of window, right wide - make left wide and move
       jmp  control_climber_horz_5a      ; Left hand at right side of window, right normal - make right wide
auto_move_5:
*      Right hand at right side of window
       mov  @left_hand_pos,r0
       jgt  control_climber_horz_5a      ; Left hand at left side of window - make right wide
       jlt  control_climber_horz_3a      ; Left hand at right side of window - make right normal and move
       abs  @right_wide
       jne  control_climber_horz_3a      ; Make right normal and move
       abs  @left_wide
       jeq  control_climber_horz_0a      ; Left hand at wall, left normal - make left wide
       jmp  control_climber_horz_2a      ; Left hand at wall, left wide - make left normal
control_climber_horz_0:
*      Left
       abs  @right_grip                ; Can only move left arm if right hand has a grip
       jeq  control_climber_horz_5
       abs  @left_wide
       jne  control_climber_horz_1
*      Left is normal
       abs  r1                         ; S (1st)
       jeq  control_climber_horz_5
control_climber_horz_0a:
       seto @left_wide                 ; Make left wide
       jmp  control_climber_horz_4
*      Left is wide
control_climber_horz_1:
       abs  @right_wide
       jne  control_climber_horz_3
*      Left is wide and right is normal
       abs  r1                         ; S (2nd)
       jeq  control_climber_horz_2
control_climber_horz_1a:
       seto @right_wide                ; Make right wide
       li   r0,8                       ; Move 8 pixels left
       s    r0,@climber_pos
       jmp  control_climber_horz_9
control_climber_horz_2:
       abs r2                          ; F (2nd)
       jeq  control_climber_horz_5
control_climber_horz_2a:
       clr  @left_wide                 ; Make left normal
       jmp  control_climber_horz_4
*      Left is wide and right is wide
control_climber_horz_3:
       abs r2                          ; F (1st)
       jeq  control_climber_horz_5
control_climber_horz_3a:
       clr  @right_wide                ; Make right normal
       li   r0,8                       ; Move 8 pixels right
       a    r0,@climber_pos
       jmp  control_climber_horz_9
control_climber_horz_4:
       bl   @update_climber_attrs_left
       jmp  control_climber_horz_11
*      Right
control_climber_horz_5:
       abs  @left_grip                 ; Can only move right arm if left hand has a grip
       jeq  control_climber_horz_11
       abs  @right_wide
       jne  control_climber_horz_6
*      Right is normal
       abs  r4                         ; L
       jeq  control_climber_horz_11
control_climber_horz_5a:
       seto @right_wide                 ; Make right wide
       jmp  control_climber_horz_10
*      Right is wide
control_climber_horz_6:
       abs  @left_wide
       jne  control_climber_horz_8
*      Right is wide and left is normal
       abs  r4                         ; L
       jeq  control_climber_horz_7
control_climber_horz_6a:
       seto @left_wide                 ; Make left wide
       li   r0,8                       ; Move 8 pixels right
       a    r0,@climber_pos
       jmp  control_climber_horz_9
control_climber_horz_7:
       abs  r3                         ; J
       jeq  control_climber_horz_11
control_climber_horz_7a:
       clr  @right_wide                 ; Make right normal
       jmp  control_climber_horz_10
*      Right is wide and left is wide
control_climber_horz_8:
       abs  r3                         ; J
       jeq  control_climber_horz_11
control_climber_horz_8a:
       clr  @left_wide                 ; Make left normal
       li   r0,8                       ; Move 8 pixels left
       s    r0,@climber_pos
control_climber_horz_9:
       bl   @update_climber_attrs_left
control_climber_horz_10:
       bl   @update_climber_attrs_right
control_climber_horz_11:
       .endproc
*// control_climber_horz

*********************************************************************
*
* Display climber sprites
*
display_climber_sprites:
       .proc
       mov  @vdp_status,r0
       andi r0,>4000                   ; Test 5th sprite flag
       jeq  display_climber_sprites_1
       li   r1,sprite_attributes_body
       li   r2,2
       jmp  display_climber_sprites_4
display_climber_sprites_1:
       movb @sprite_attributes_head+2,r0
       jeq  display_climber_sprites_2
       li   r0,sprite_attributes_head
       movb *r0+,*r15
       movb *r0+,*r15
       movb *r0+,*r15
       movb *r0+,*r15
display_climber_sprites_2:
       movb @sprite_attributes_head+6,r0
       jeq  display_climber_sprites_3
       li   r0,sprite_attributes_head+4
       movb *r0+,*r15
       movb *r0+,*r15
       movb *r0+,*r15
       movb *r0+,*r15
display_climber_sprites_3:
       li   r1,sprite_attributes_head+8
       li   r2,3
display_climber_sprites_4:
       clr  r3
       bl   @vm8bw_pad
       .endproc
*// display_climber_sprites

*********************************************************************
*
* Handle other sprites
*
handle_other_sprites:
       .proc
       li   r3,sprites
handle_other_sprites_1:
       mov  *r3,r0                     ; sprite_handler
       jeq  handle_other_sprites_2
       bl   *r0
handle_other_sprites_2:
       ai   r3,sprite_size
       ci   r3,sprites_end
       jl   handle_other_sprites_1
       .endproc
*// handle_other_sprites

*********************************************************************
*
* Resident person handler
*
* r3: sprite structure
*
resident_handler:
       .proc
       mov  @sprite_count(r3),r0       ; Init?
       jne  resident_handler_1         ; Jump if not
       li   r0,24
       mov  r0,@sprite_count(r3)
resident_handler_1:
       mov  @sprite_x(r3),r0
       mov  @sprite_y(r3),r1
       bl   @window_screen_coords
       mov  r1,r1
       jlt  resident_handler_3
       dec  r1
       swpb r1
       movb r1,*r15
       swpb r0
       movb r0,*r15
       li   r0,spr_resident*256
       movb r0,*r15
       li   r0,>0f00                   ; White
       movb r0,*r15
       c    @sprite_count(r3),@resident_handler_drop
       jne  resident_handler_2
       bl   @create_plant
resident_handler_2:
       dec  @sprite_count(r3)
       jne  resident_handler_3
       clr  @sprite_handler(r3)        ; Handler done
resident_handler_3:
       .endproc
resident_handler_drop:
       data 16
*// resident_handler

*********************************************************************
*
* Dropping plant handler
*
* r3: sprite structure
*
plant_handler:
       .proc
       mov  @sprite_y(r3),r1
       dec  r1
       swpb r1
       movb r1,*r15
       mov  @sprite_x(r3),r0
       swpb r0
       movb r0,*r15
       li   r0,spr_plant_1*256
       movb r0,*r15
       li   r0,>0c00                   ; Green
       movb r0,*r15
       mov  @sprite_y(r3),r0
       s    @scroll_dy,r0
       ai   r0,4
       mov  r0,@sprite_y(r3)
       ci   r0,194
       jl   plant_handler_1
       clr  @sprite_handler(r3)
plant_handler_1:
       .endproc
*// plant_handler

*********************************************************************
*
* Create resident
*
* r3 points to window structure (must be preserved)
*
create_resident:
       .proc
       bl   @allocate_sprite
       mov  r4,r4
       jeq  create_resident_1
       li   r0,resident_handler
       mov  r0,@sprite_handler(r4)     ; sprite_handler
       mov  @window_anim_row(r3),@sprite_y(r4)   ; sprite_y
       mov  @window_anim_col(r3),@sprite_x(r4)   ; sprite_x
       clr  @sprite_count(r4)          ; sprite_count
create_resident_1:
       .endproc
*// create_resident

*********************************************************************
*
* Create plant
*
* r3 points to sprite structure of resident (must be preserved)
*
create_plant:
       .proc
       bl   @allocate_sprite
       mov  r4,r4
       jeq  create_plant_1
       li   r0,plant_handler
       mov  r0,@sprite_handler(r4)     ; sprite_handler
       mov  @sprite_x(r3),r0
       mov  @sprite_y(r3),r1
       bl   @window_screen_coords
       ai   r1,16
       mov  r1,@sprite_y(r4)           ; sprite_y
       mov  r0,@sprite_x(r4)           ; sprite_x
       clr  @sprite_count(r4)          ; sprite_count
create_plant_1:
       .endproc
*// create_plant

*********************************************************************
*
* Allocate sprite
*
* Return sprite address in r4 or zero if no sprte available
*
allocate_sprite:
       li   r4,sprites
allocate_sprite_1:
       mov  *r4,*r4
       jeq  allocate_sprite_2
       ai   r4,sprite_size
       ci   r4,sprites_end
       jne  allocate_sprite_1
       clr  r4
allocate_sprite_2:
       rt
*// allocate_sprite

*********************************************************************
*
* Position of climber's left hand in map
*
* On return r2 contains the address in the map
*
left_hand_map_addr:
       .proc
       mov  @climber_pos,r0
*      Y offset
       bl   @left_hand_y_offset
       inct r1
       swpb r1
       ab   r1,r0
*      X offset
       abs  @left_wide
       jne  left_hand_map_addr_1
       ai   r0,>0008
left_hand_map_addr_1:
       bl   @sprite_map_addr
       .endproc
*// left_hand_map_addr

*********************************************************************
*
* Y offset of climber's left hand
*
* On return r1 contains the offset
*
left_hand_y_offset:
       mov  @left_anim_ptr,r1
       ai   r1,-left_anim
       srl  r1,3
       sla  r1,2
       rt
*// left_hand_offset


*********************************************************************
*
* Left hand position
*
* On return r1 contains the position: -1=window right, 0=wall, 1=window left
*
left_hand_position:
       mov  @climber_pos,r1
       andi r1,>00ff                   ; x
       abs  @left_wide
       jne  left_hand_position_1
       ai   r1,>0008
left_hand_position_1:
       ai   r1,->0040                  ; Minus left position of building
       clr  r0
       div  @w_24,r0                   ; 0, 8, 16
       ai   r1,-8                      ; -8, 0, 8
       sra  r1,3                       ; -1, 0, 1
       rt
*// left_hand_position_1

*********************************************************************
*
* Position of climber's right hand in map
*
* On return r2 contains the address in the map
*
right_hand_map_addr:
       .proc
       mov  @climber_pos,r0
*      Y offset
       bl   @right_hand_offset
       inct r1
       swpb r1
       ab   r1,r0
*      X offset
       ai   r0,>0010
       abs  @right_wide
       jeq  right_hand_map_addr_1
       ai   r0,>0008
right_hand_map_addr_1:
       bl   @sprite_map_addr
       .endproc
*// right_hand_map_addr

*********************************************************************
*
* Y offset of climber's right hand
*
* On return r1 contains the offset
*
right_hand_offset:
       mov  @right_anim_ptr,r1
       ai   r1,-right_anim
       srl  r1,3
       sla  r1,2
       rt
*// left_hand_offset

*********************************************************************
*
* Right hand position
*
* On return r1 contains the position: -1=window right, 0=wall, 1=window left
*
right_hand_position:
       mov  @climber_pos,r1
       andi r1,>00ff                   ; x
       ai   r1,>0010
       abs  @right_wide
       jeq  right_hand_position_1
       ai   r1,>0008
right_hand_position_1:
       ai   r1,->0040                  ; Minus left position of building
       clr  r0
       div  @w_24,r0                   ; 0, 8, 16
       ai   r1,-8                      ; -8, 0, 8
       sra  r1,3                       ; -1, 0, 1
       rt
*// right_hand_position

*********************************************************************
*
* Map address at given screen coordinates
*
* r0: Screen coordinates of sprite y/x
*
* On return r2 contains the address in the map
*
sprite_map_addr:
       mov  r0,r1
       andi r0,>00ff                   ; x
       ai   r0,->0040                  ; Minus left position of building
       srl  r0,3                       ; To characters
       swpb r1
       andi r1,>00ff                   ; y
       inc  r1
       a    @scroll_y,r1
       srl  r1,3                       ; To character rows
       mpy  @MS0,r1                    ; Multiply by map width
       a    r0,r2                      ; Add x
       ai   r2,MD0                     ; Add base
       rt
*// sprite_map_addr

*********************************************************************
*
* Window address in map
*
* r0: window column
* r1: window row
*
* On return r2 contains the address in the map
*
window_map_addr:
       .push r1
       mpy  @MS0,r1                    ; Multiply by map width to r2
       sla  r2,1                       ; Two rows per window
       ai   r2,MD0-map_width+2         ; Add address of start of map + offset for left wall
       a    r0,r2                      ; Add x to address x 1
       a    r0,r2                      ; Add x to address x 2
       a    r0,r2                      ; Add x to address x 3
       .pop r1
       rt
*// window_map_addr

*********************************************************************
*
* Window screen coordinates
*
* r0: window column
* r1: window row
*
* On return r0 and r1 contain the screen coordinates (x, y), r2 is modified
*
window_screen_coords:
       sla  r0,3                       ; column * 8
       mov  r0,r2
       sla  r0,1                       ; column * 16
       a    r2,r0                      ; column * 24
       ai   r0,>50                     ; Add offset from left
       sla  r1,4                       ; row * 16
       s    @scroll_y,r1               ; Minus scroll offsset
       rt
*// window_screen_coords

*********************************************************************
*
* Checks whether r2 points to a fully open window in the map
*
* On return EQ means that it's an open window. r1 is modified.
*
is_open_window:
       clr  r1
       movb *r2,r1
       swpb r1
       sla  r1,1
       mov  @TCHARS(r1),r1
       cb   @b_window_open_top,r1
;       jeq  is_open_window_1
;       swpb r1
;       cb   @b_window_open_top,r1
;is_open_window_1:
       rt
*// is_open_window

*********************************************************************
*
* Checks whether r2 points to a window with the bottom open in the map
*
* On return EQ means that it's an open window. r1 is modified.
*
is_open_window_bottom:
       clr  r1
       movb *r2,r1
       swpb r1
       sla  r1,1
       mov  @TCHARS(r1),r1
       swpb r1
       cb   @b_window_open_bottom,r1
;       jeq  is_open_window_bottom_1
;       swpb r1
;       cb   @b_window_open_bottom,r1
;is_open_window_bottom_1:
       rt
*// is_open_window_bottom

*********************************************************************
*
* Generate a pseudo random number within the given limit
*
* R2: Maximum number (0 - 255) exclusive
*
* On return R0 contains the number [0; R1[
*
rand_max:
       .proc
       bl   @rand                      ; generate a random number in r0
       andi r0,>00ff                   ; clear msb: [0-255]
       mpy  r2,r0                      ; width * [0-255]
       srl  r1,8                       ; (width * [0-255]) / 256
       mov  r1,r0                      ; copy result back
       .endproc
*// rand_max

*********************************************************************
*
* Generate a pseudo random number
*
* On return R0 contains the number, which is also stored at @RANDNO
*
* r0 and r1 are modified
*
rand:
       li   r0,28643                   ; A prime number to multiply by
       mpy  @rand_no,r0                ; Multiply by last random number
       ai   r1,31873                   ; Add a prime number
       src  r1,7                       ; Mix up the number to break odd/even pattern
       mov  r1,@rand_no                ; Save this number for next time
       mov  r1,r0
       rt
*// rand

*********************************************************************
*
* Display initial screen
*
* If sprites beyond 0-7 are to be used on a real 9918A VDP we need to update
* the second and third part of the pattern table as well (with the same 
* patterns). The color table is always OK at >800 bytes. See GMODE.
*
initial_screen:
       .proc
*      Upload patterns 1st part
       li   r0,65*8+pattern_table      ; Non-scrolling characters
       li   r1,PAT65
       li   r2,55*8
       bl   @vmbw
       li   r0,pattern_table           ; destination address in vdp ram
       li   r1,PSTRIP                  ; address of first scrolled pattern frame
       mov  @tchnum,r2                 ; number of patterns of 8 bytes
       bl   @vm8bw8                    ; call copying routine
*      Upload patterns 2nd part
       li   r0,65*8+pattern_table_1    ; Non-scrolling characters
       li   r1,PAT65
       li   r2,55*8
       bl   @vmbw
       li   r0,pattern_table_1         ; destination address in vdp ram
       li   r1,PSTRIP                  ; address of first scrolled pattern frame
       mov  @tchnum,r2                 ; number of patterns of 8 bytes
       bl   @vm8bw8                    ; call copying routine
*      Upload patterns 3rd part
       li   r0,65*8+pattern_table_2    ; Non-scrolling characters
       li   r1,PAT65
       li   r2,55*8
       bl   @vmbw
       li   r0,pattern_table_2         ; destination address in vdp ram
       li   r1,PSTRIP                  ; address of first scrolled pattern frame
       mov  @tchnum,r2                 ; number of patterns of 8 bytes
       bl   @vm8bw8                    ; call copying routine
*      Upload colors
       li   r0,65*8+color_table        ; Non-scrolling colors
       li   r1,COL65
       li   r2,55*8
       bl   @vmbw
       LI   r0,color_table             ; Destination address in VDP RAM
       li   r1,CSTRIP                  ; address of first scrolled color frame
       mov  @tchnum,r2                 ; number of pattern colors of 8 bytes
       bl   @vm8bw8                    ; call copying routine
*      Init name tables
       mov  @scroll_y,r4               ; get initial scroll offset in pixels
       srl  r4,3                       ; convert to row offset
       mov  r4,r5
       mpy  @MS0,r5                    ; convert to map offset in r6
*      Table 0
       li   r0,name_table_0
       li   r1,MD2
       li   r2,>300
       bl   @vmbw
       li   r0,name_table_0+8          ; destination address in vdp ram
       li   r1,md0                     ; base address of map data
       a    r6,r1                      ; add map offset
       li   r7,24                      ; number of rows
inisc1:
       bl   @copy_row
       ai   r0,32
       dec  r7
       jne  inisc1
*      Table 1
       li   r0,name_table_1
       li   r1,MD2
       li   r2,>300
       bl   @vmbw
       li   r0,name_table_1+8          ; destination address in vdp ram
       li   r1,MD0                     ; base address of map data
       a    r6,r1                      ; add map offset
       li   r7,24                      ; number of rows
inisc2:
       bl   @copy_row_hi
       ai   r0,32
       dec  r7
       jne  inisc2
       .endproc
*// initial_screen

*********************************************************************
*
* Climber climbs the first few floors up by himself
*
intro_climb:
       .proc
       li   r0,intro_module
       bl   @play_module
       li   r0,>9da8
       mov  r0,@climber_pos
       li   r8,4
intro_climb_1:
       li   r9,intro_climb_data
intro_climb_2:
       mov  *r9+,@left_anim_ptr
       mov  *r9+,@left_wide
       mov  *r9+,@right_anim_ptr
       mov  *r9+,@right_wide
       mov  *r9+,r7                    ; dy
       sb   r7,@climber_pos
       li   r6,4
intro_climb_3:
       bl   @vsync
       bl   @update_climber_attrs_left
       bl   @update_climber_attrs_right
       bl   @display_sprites
       bl   @int_routine
       dec  r6
       jne  intro_climb_3
       ci   r9,intro_climb_data_end
       jne  intro_climb_2
       dec  r8
       jne  intro_climb_1
*      Say go for it
       li   r0,speech_go_for_it_idx
       bl   @speak
       .endproc
intro_climb_data:
       data left_anim, 0, right_anim, 0, >0000
       data left_anim_1, 0, right_anim_1, 0, >0400
       data left_anim_2, 0, right_anim_2, 0, >0400
       data left_anim_3, 0, right_anim_3, 0, >0400
       data left_anim_4, 0, right_anim_4, 0, >0400
       data left_anim_4, 0, right_anim_4, 1, >0000
       data left_anim_4, 0, right_anim_3, 1, >0000
       data left_anim_4, 0, right_anim_2, 1, >0000
       data left_anim_4, 0, right_anim_1, 1, >0000
       data left_anim_4, 0, right_anim, 1, >0000
       data left_anim_4, 0, right_anim, 0, >0000
       data left_anim_4, 1, right_anim, 0, >0000
       data left_anim_3, 1, right_anim, 0, >0000
       data left_anim_2, 1, right_anim, 0, >0000
       data left_anim_1, 1, right_anim, 0, >0000
       data left_anim, 1, right_anim, 0, >0000
intro_climb_data_end:
       equ  $
*// intro_climb

*********************************************************************
*
* One time initializations
*
one_time_init:
       .proc
       li   r15,vdpwd
       li   r0,1
       mov  r0,@one
       li   r0,2
       mov  r0,@two
       mov  @>83c0,r1                  ; Random number seed
*      Clear scratchpad
       li   r0,padvar
       li   r2,pad_max-padvar
       bl   @clear
*      Randomize
;       mov  r1,@rand_no
*      Copy code to scratchpad
       li   r0,vm8bw1
       li   r1,vm8bw_pad
       li   r2,vm8bw1_end-vm8bw1
       bl   @copy
       bl   @copy_speech_read_to_pad
*      Detect speech
       bl   @speech_check
*      Setup graphics mode
       bl   @graphics_mode             ; call setup routine
*      Sprite patterns
       li   r0,sprite_pattern_table
       li   r1,SPR0
       li   r2,64*32
       bl   @vmbw
*      Clear sprites table
       li   r0,sprites
       li   r2,sprites_end-sprites
       bl   @clear
*      Clear window animations table
       li   r0,window_anims
       li   r2,window_anims_end-window_anims
       bl   @clear
       .endproc
*// one_time_init

*********************************************************************
*
* Set graphics mode
*
graphics_mode:
       .proc
       clr  r0
       li   r1,vdp_registers
       li   r2,8
graphics_mode_1:
       movb *r1+,@r0lb
       bl   @vwtr                      ; Set register
       ai   r0,>0100
       dec  r2
       jne  graphics_mode_1
*      Clear VDP RAM
       clr  r0
       clr  r1
       li   r2,>4000
       bl   @vsmw
*      Disable sprites
       li   r0,sprite_attr_table
       li   r1,>d000
       bl   @vsbw
       .endproc
*      VDP registers
vdp_registers:
       byte >02                        ; Graphics II mode
       byte >e2                        ; 16K, display on, interrupt
       byte name_table_0/>400          ; Name table
       byte >9f                        ; Color table
       byte pattern_table/>800+>03     ; Pattern table x 3
       byte sprite_attr_table/>80      ; Sprite attribute table
       byte sprite_pattern_table/>800  ; Sprite pattern table
       byte >01                        ; Backdrop color
*// graphics_mode

*********************************************************************
*
* Clear CPU memory
*
clear:
       clr  *r0+
       dect r2
       jne  clear
       rt
*// clear


*********************************************************************
*
* Copy CPU memory
*
copy:
       mov  *r0+,*r1+
       dect r2
       jne  copy
       rt
*// copy

***************************************************************************
*
* Check key
*
* r0: Column in MSB: >0000 - >0700, Row in LSB: >0006 - >0014
*
*       Column   0      1    2    3    4    5     6       7
*     Row
*     >0006      =      .    ,    M    N    /    Fire    Fire
*     >0008    Space    L    K    J    H    ;    Left    Left
*     >000A    Enter    O    I    U    Y    P    Right   Right
*     >000C             9    8    7    6    0    Down    Down
*     >000E    Fctn     2    3    4    5    1    Up      Up
*     >0010    Shift    S    D    F    G    A
*     >0012    Ctrl     W    E    R    T    Q
*     >0014             X    C    V    B    Z
*
* On return NEQ means that the key is pressed
*
KEY_FI EQU  >0606
KEY_LF EQU  >0608
KEY_RG EQU  >060A
KEY_DN EQU  >060C
KEY_UP EQU  >060E
KEY_CM EQU  >0206
KEY_FS EQU  >0106
KEY_0  EQU  >050C
KEY_1  EQU  >050E
KEY_2  EQU  >010E
KEY_3  EQU  >020E
KEY_4  EQU  >030E
KEY_5  EQU  >040E
KEY_6  EQU  >040C
KEY_7  EQU  >030C
KEY_8  EQU  >020C
KEY_9  EQU  >010C
KEY_A  EQU  >0510
KEY_B  EQU  >0414
KEY_C  EQU  >0214
KEY_D  EQU  >0210
KEY_E  EQU  >0212
KEY_F  EQU  >0310
KEY_G  EQU  >0410
KEY_H  EQU  >0408
KEY_I  EQU  >020A
KEY_J  EQU  >0308
KEY_K  EQU  >0208
KEY_L  EQU  >0108
KEY_M  EQU  >0306
KEY_N  EQU  >0406
KEY_O  EQU  >010A
KEY_P  EQU  >050A
KEY_Q  EQU  >0512
KEY_R  EQU  >0312
KEY_S  EQU  >0110
KEY_T  EQU  >0412
KEY_U  EQU  >030A
KEY_V  EQU  >0314
KEY_W  EQU  >0112
KEY_X  EQU  >0114
KEY_Y  EQU  >040A
KEY_Z  EQU  >0514
KEY_SP EQU  >0008
KEY_EN EQU  >000A
KEY_FN EQU  >000E
KEY_SH EQU  >0010
KEY_CT EQU  >0012
JOY_FI EQU  >0606
JOY_LT EQU  >0608
JOY_RT EQU  >060A
JOY_DN EQU  >060C
JOY_UP EQU  >060E
*
check_key:
       li   r12,>0024                  ; CRU address of the column decoder
       ldcr r0,3                       ; Select column
       andi r0,>00ff
       mov  r0,r12                     ; Select row
       tb   0                          ; Test key, EQ if not pressed
       rt
*// check_key

*********************************************************************
*
*       Includes
*
       copy "vdp.a99"
       copy "sound-player.a99"
       copy "music-player.a99"
       copy "sound-fx-routines.a99"
       copy "speech.a99"

lower_memory_max:
       equ  $

*********************************************************************
*
*       Data
*
       aorg >A000

       copy "graphics.a99"
       copy "screen.a99"
       copy "sprite-patterns.a99"
       copy "map-animations.a99"
       copy "sprite-animations.a99"
       copy "sound-fx.a99"
       copy "intro-music.a99"
       copy "speech-data.a99"

window_anim_row:
       equ  0
window_anim_col:
       equ  2
window_anim_type:
       equ  4
window_anim_frame:
       equ  6
window_anim_next:
       equ  8
window_anim_prev:
       equ  10
window_anim_size:
       equ  12

window_anim_type_window:
       equ  0
window_anim_type_resident:
       equ  1

;windows_head_ptr:
;       data 0
;windows_tail_ptr:
;       data 0
window_anims:
       bss  n_windows*window_anim_size
window_anims_end:
       data -1

b_window_closed_tch:                   ; Window left bottom closed -> Window left closed 5
       byte >00
b_window_open_top:                     ; Original window open top char
       byte >04
b_window_open_bottom:                  ; Original window open bottom char
       byte >05
b_building_left:
       byte >40
b_building_right:
       byte >c8
b_unused:
       byte >00
w_24:
       data 24

sprite_attributes_head:
       byte >ad,>a8,0,>09              ; Left
       byte >ad,>b8,0,>09              ; Right
       byte >9d,>a8,spr_lft_top_2nd_norm_1,>09
       byte >9d,>b8,spr_rgt_top_2nd_norm_1,>09
sprite_attributes_body:
       byte >9d,>a8,spr_lft_top_norm_1,>02
       byte >9d,>b8,spr_rgt_top_norm_1,>02
       byte >ad,>a8,spr_lft_bot_norm_1,>02
       byte >ad,>b8,spr_rgt_bot_norm_1,>02

sprite_handler:
       equ  0
sprite_y:
       equ  2
sprite_x:
       equ  4
sprite_count:
       equ  6
sprite_vy:
       equ  8
sprite_vx:
       equ  10
sprite_ay:
       equ  12
sprite_ax:
       equ  14
sprite_size:
       equ  16

       even
sprites:
       bss  n_sprites*sprite_size
sprites_end:
       equ  $

upper_memory_max:
       equ  $

       end  start
