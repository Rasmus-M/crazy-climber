*********************************************************************
*
* Crazy climber
*
* Rasmus Moustgaard <rasmus.moustgaard@gmail.com>
*
*********************************************************************

       def   start

       copy "macros.a99"
       copy "sound-defs.a99"
       copy "speech-defs.a99"

       copy "rom-bank-4.a99"
       copy "rom-bank-5.a99"
       copy "rom-bank-6.a99"
       copy "rom-bank-7.a99"

**
* Memory mapped addresses
*
vdpwd:                                 ; VDP write data
       equ  >8c00
vdpwa:                                 ; VDP set read/write address
       equ  >8c02
vdprd:                                 ; VDP read data
       equ  >8800
vdpsta:                                ; VDP status
       equ  >8802
sound:                                 ; Sound
       equ  >8400
spchwt:
       equ  >9400
spchrd:
       equ  >9000


*       VPD RAM Map
pattern_table:                         ; Pattern table base
       equ  >0000
pattern_table_1:                       ; Pattern table part 2
       equ  >0800
pattern_table_2:                       ; Pattern table part 3
       equ  >1000
sprite_pattern_table:                  ; Sprite pattern table
       equ  >1800
color_table:                           ; Color table base
       equ  >2000
name_table_0:                          ; Name table base 0 (>0A)
       equ  >2800
name_table_1:                          ; Name table base 1 (>0B)
       equ  >2C00
sprite_attr_table:                     ; Sprite attribute table
       equ  >3000

*      Constants
falling_enabled:
       equ  1
test_bird:
       equ  0
test_kong:
       equ  0
test_chopper:
       equ  0
start_level:
       equ  0                          ; 0 is building 1
map_width:
       equ  22
map_height:
       equ  425
scroll_max:
       equ  >0c88
n_levels:
       equ  4
n_windows:
       equ  12
n_sprites:
       equ  16
attenuation_during_speech:
       equ  2
initial_climber_position:
       equ  >6da8
chr_zero:
       equ  96
chr_window_open_top:
       equ  4
chr_window_open_bottom:
       equ  5
chr_window_left_bottom_closed:
       equ  16
chr_window_right_bottom_closed:
       equ  17
chr_face_first:
       equ  18
chr_face_last:
       equ  25
chr_life:
       equ  111
chr_space:
       equ  106
chr_prog:
       equ  255
kong_row:
       equ  >88
title_bank_select:
       equ  >6008
level_1_bank_select:
       equ  >600a
level_2_bank_select:
       equ  >600e
level_3_bank_select:
       equ  >600c
level_4_bank_select:
       equ  >600e

**
* Scratch pad
*
pad:
       equ  >8300
wrksp:
       equ  pad                        ; Workspace
r0lb:
       equ  wrksp+1
r1lb:
       equ  wrksp+3
r2lb:
       equ  wrksp+5
r3lb:
       equ  wrksp+7
wrksp2:
       equ  wrksp+>20
stack:
       equ  wrksp2+>20
**
* PAD variables
*
padvar:                                ; Start of pad variables
       equ  stack+>10
rand_no:                               ; Random number seed
       equ  padvar
vdp_status:                            ; VDP status byte
       equ  rand_no+2
frame:                                 ; Frame counter
       equ  vdp_status+2
sprite_dupl_bug:                       ; Does VDP have sprite duplication bug?
       equ  frame+2
scroll_y:                              ; Vertical scroll offset
       equ  sprite_dupl_bug+2
scroll_dy:                             ; Scroll direction
       equ  scroll_y+2
climber_pos:                           ; Climber y/x position in screen coordinates
       equ  scroll_dy+2
left_anim_ptr:                         ; Left animation pointer
       equ  climber_pos+2
right_anim_ptr:                        ; Right animation pointer
       equ  left_anim_ptr+2
left_ascending:                        ; Flag: ascending on left side?
       equ  right_anim_ptr+2
right_ascending:                       ; Flag: ascending on right side?
       equ  left_ascending+2
left_grip:                             ; Flag: left hand is placed on bottom of window
       equ  right_ascending+2
right_grip:                            ; Flag: right hand is placed on bottom of window
       equ  left_grip+2
left_hand_pos:                         ; Left hand position: -1=window right, 0=wall or no grip, 1=window left
       equ  right_grip+2
right_hand_pos:                        ; Right hand position: 1=window right, 0=wall or no grip, -1=window left
       equ  left_hand_pos+2
left_wide:                             ; Flag: wide on left side?
       equ  right_hand_pos+2
right_wide:                            ; Flag: wide on right side?
       equ  left_wide+2
animation_count:                       ; Number of frames to repeat last animation frame
       equ  right_wide+2
inactivity_count:                      ; Incremented when player is inactive
       equ  animation_count+2
animation_changed:                     ; Flag: did animation frame (left or right) change?
       equ  inactivity_count+2
windows_head_ptr:                      ; Head of window animation list
       equ  animation_changed+2
windows_tail_ptr:                      ; Head of window animation list
       equ  windows_head_ptr+2
next_stage_ptr:                        ; Pointer to next stage in the stages list
       equ  windows_tail_ptr+2
max_residents:                         ; Maximum residents together on screen
       equ  next_stage_ptr+2
current_residents:                     ; Currently disaplyed residents
       equ  max_residents+2
secondary_sprite_patterns:             ; Secondary sprite patterns loaded (0 = head and hands)
       equ  current_residents+2
control_set:                           ; Points to current control set (joystick_control or keyboard_control)
       equ  secondary_sprite_patterns+2
status:                                ; Game status (-1 = dead, 0 = normal, 1 = finished, 2 = finished but not picked up by chopper)
       equ  control_set+2
level:                                 ; Current level, 0 - ...
       equ  status+2
lives:                                 ; Number of lives
       equ  level+2
score:                                 ; Score LSW
       equ  lives+2
score_msw:                             ; Score MSW
       equ  score+2
disp_score:                            ; Currently displayed score (LSW)
       equ  score_msw+2
bonus:                                 ; Bonus (counts down)
       equ  disp_score+2
demo_mode:
       equ  bonus+2
snd_channel_1:                         ; Sound/music player data
       equ  demo_mode+2
snd_channel_2:
       equ  snd_channel_1+snd_channel_size
snd_channel_3:
       equ  snd_channel_2+snd_channel_size
snd_channel_4:
       equ  snd_channel_3+snd_channel_size
snd_track_1:
       equ  snd_channel_4+snd_channel_size
snd_track_2:
       equ  snd_track_1+snd_track_size
snd_track_3:
       equ  snd_track_2+snd_track_size
snd_track_4:
       equ  snd_track_3+snd_track_size
module_speed:
       equ  snd_track_4+snd_track_size
speech_detected:                       ; Speech data
       equ  module_speed+2
speech_reserved:
       equ  speech_detected+2
speech_status:
       equ  speech_reserved+2
speech_addr:
       equ  speech_status+2
speech_counter:
       equ  speech_addr+2
speech_read_pad:
       equ  speech_counter+2
vm8bw_pad:                             ; Copy routine
       equ  speech_read_pad+14
pad_max:                               ; Max scratchpad address used
       equ  vm8bw_pad+24

*********************************************************************
*
*      Lower memory
*
       aorg >2000

start  limi 0                          ; disable interrupts
       lwpi wrksp                      ; setup workspace
       li   r10,stack                  ; use r10 as stack pointer
       bl   @one_time_init
new_game:
       bl   @title_screen
       bl   @initial_static_screen
       bl   @game_init
next_level:
       bl   @level_init
       bl   @intro_climb
restart_level:
       bl   @restart_init
*      Main loop
       clr  @frame
main_loop:
       bl   @main_loop_body
*      Check status
       mov  @status,r0
       jgt  finished
       jlt  died
*      Loop
       inc  @frame
       jmp  main_loop
*      Main loop terminated
finished:
       ci   r0,1
       jeq  finished_1
*      Level completed without chopper pickup
       li   r0,3000
       mov  r0,@bonus
finished_1:
*      Level completed with chopper pickup
       bl   @chopper_pickup
       mov  @level,r0
       inc r0
       andi r0,n_levels-1
       mov  r0,@level
       jmp  next_level
died:
*      Died
       bl   @fall_sequence
       dec  @lives
       jne  restart_level
*      Game over
       bl   @record_high_score
       b    @new_game
*// main_loop

*********************************************************************
*
* One iteration of the main loop
*
main_loop_body:
       .proc
*      Wait for vsync
       bl   @vsync
*      Set name table
       bl   @set_name_table
*      Music and speech
       bl   @int_routine
*      Display sprites
       bl   @display_sprites
*      Control climber
       bl   @check_grip
       bl   @control_climber_vert
       bl   @check_int
       bl   @control_climber_horz
       bl   @check_int
*      Change scroll offset
       bl   @change_scroll_offset
*      Animate windows and faces
       mov  @frame,r0                  ; Only do this every 4th frame
       andi r0,>0003
       ci   r0,>0001                   ; Frame 1, 5, 9, 13, ...
       jne  !
       bl   @animate_windows
       bl   @check_int
!      mov  @frame,r0                  ; Only do this every 16th frame
       andi r0,>000f                   ; Frame 0, 16, 32, 64 ...
       jne  !
       bl   @create_windows
       bl   @check_int
*      Update patterns
!      bl   @update_pattern_table
*      Update name table buffer
       bl   @update_name_table
       bl   @display_score
       bl   @update_and_display_bonus
       bl   @display_progress
*      Update stage
       bl   @update_stage
*      Check for inactivity
       bl   @check_for_inactivity
       .endproc
*// vsync

*********************************************************************
*
* Wait for vsync
*
vsync:
       movb @vdpsta,@vdp_status        ; Clear flag if already set
       clr  r12
vsync1:
       tb   2
       jeq  vsync1
       socb @vdpsta,@vdp_status
       b    *r11
*// vsync

*********************************************************************
*
* Test for interrupt and execute interrupt routine if found
*
check_int:
       clr  r12
       tb   2
       jeq  check_int_1
       movb @vdpsta,@vdp_status
       .proc
       bl   @int_routine
       .endproc
check_int_1:
       b    *r11
*// check_int

*********************************************************************
*
* Interrupt routine
*
int_routine:
       lwpi wrksp2
       mov  @wrksp+20,r10
       bl   @module_player
       bl   @speech_player
       bl   @check_quit
       lwpi wrksp
       rt
*// int_routine

*********************************************************************
*
* Set name table
*
* Altenate between tables 0 and 1
*
* Tables 0 contain 'names' from the low character set (0-127)
* Tables 1 contain 'names' from the high character set (128-255)
*
* Modifies r0
*
set_name_table:
       .proc
       mov  @frame,r0                  ; Get frame
       andi r0,1
       ai   r0,>020a
       bl   @vwtr
       .endproc
*// set_name_table

*********************************************************************
*
* Display sprites
*
display_sprites:
       .proc
       li   r0,sprite_attr_table
       bl   @vwad
       mov  @frame,r0
       andi r0,1
       jne  display_sprites_1
       bl   @display_climber_sprites
display_sprites_1:
       bl   @handle_other_sprites
       mov  @frame,r0
       andi r0,1
       jeq  display_sprites_2
       bl   @display_climber_sprites
display_sprites_2:
       li   r1,>d000                   ; Write end marker
       movb r1,*r15
       .endproc
*// display_sprites

*********************************************************************
*
* Update pattern and color tables
*
* Alternate between updating low (0-127) or high (128-255) half of
* the character set. The set that is updated is not used (and therefore
* not visible) in the currently displayed name table. This provides the
* desired double buffering effect.
*
* Modifies R0-R4
*
update_pattern_table:
       .proc
*      Calculate VDP RAM destination address
       mov  @frame,r0                  ; Read frame into register
       inv  r0
       andi r0,1
       sla  r0,10                      ; 0 or >400
       ai   r0,pattern_table
*      Calculate cpu ram source address
       mov  @scroll_y,r1               ; Scroll offset
       andi r1,>0007                   ; Mod 8
       a    @pattern_strips,r1         ; Add base address of pattern strips
*      Save calculated values
       mov  r0,r4
       mov  r1,r5
*      Copy patterns 1st part
       mov  @base_scroll_chars,r2      ; Base patterns
       bl   @vm8bw8
       bl   @check_int
       mov  r4,r0                      ; Extra patterns
       a    @vdp_base_of_extra_scroll_chars,r0
       a    @cpu_offset_to_extra_scroll_chars,r1
       mov  @extra_scroll_chars,r2
       bl   @vm8bw0
       bl   @check_int
*      Only copy next to table 2 and 3 on original VDP
       abs  @sprite_dupl_bug
       jeq  update_pattern_table_1
*      Copy patterns 2nd part
       mov  r4,r0                      ; Base patterns
       ai   r0,>800
       mov  r5,r1
       mov  @base_scroll_chars,r2      ; Number of patterns
       bl   @vm8bw8
       bl   @check_int
       mov  r4,r0                      ; Extra patterns
       ai   r0,>800
       a    @vdp_base_of_extra_scroll_chars,r0
       a    @cpu_offset_to_extra_scroll_chars,r1
       mov  @extra_scroll_chars,r2
       bl   @vm8bw0
       bl   @check_int
*      Copy patterns 3rd part
       mov   r4,r0                     ; Base patterns
       ai    r0,>1000
       mov   r5,r1
       mov  @base_scroll_chars,r2      ; Number of patterns
       bl   @vm8bw8
       bl   @check_int
       mov  r4,r0                      ; Extra patterns
       ai   r0,>1000
       a    @vdp_base_of_extra_scroll_chars,r0
       a    @cpu_offset_to_extra_scroll_chars,r1
       mov  @extra_scroll_chars,r2
       bl   @vm8bw0
       bl   @check_int
update_pattern_table_1:
*      Copy colors
       mov  r4,r0                      ; Base patterns
       ai   r0,color_table
       mov  r5,r1
       a    @color_strip_offset,r1           ; Add offset between patterns and colors
       mov  @base_scroll_chars,r2      ; Number of patterns
       bl   @vm8bw8
       bl   @check_int
       mov  r4,r0                      ; Extra patterns
       ai   r0,color_table
       a    @vdp_base_of_extra_scroll_chars,r0
       a    @cpu_offset_to_extra_scroll_chars,r1
       mov  @extra_scroll_chars,r2
       bl   @vm8bw0
       bl   @check_int
       .endproc
*// update_pattern_table

*********************************************************************
*
* Update stage according to scroll position
*
update_stage:
       .proc
       mov  @next_stage_ptr,r0
       jeq  update_stage_3
       mov  *r0+,r1                    ; Scroll y
       c    r1,@scroll_y
       jl   update_stage_3
*      Next stage
       mov  *r0+,r1                    ; Init routine
       jeq  update_stage_1
       .push r0
       bl   *r1                        ; Execute init routine
       .pop r0
update_stage_1:
       c   *r0,@w_0
       jne  update_stage_2
       clr  r0
update_stage_2:
       mov  r0,@next_stage_ptr
update_stage_3:
       .endproc
*// update_stage

*********************************************************************
*
* Check for inactivity
*
check_for_inactivity:
       .proc
       inc  @inactivity_count
       mov  @inactivity_count,r0
       ci   r0,120
       jlt  check_for_inactivity_1
       li   r0,speech_go_for_it_idx
       bl   @speak
       clr  @inactivity_count
check_for_inactivity_1:
       .endproc
*// check_for_inactivity

*********************************************************************
*
* Update name table off-screen buffer
*
* Modifies R0-R4
*
update_name_table:
       .proc
*      Calculate map source address in r1
       mov  @scroll_y,r1               ; get scroll offset in pixels
       srl  r1,3                       ; divide by 8 to get row offset
       mpy  @w_map_width,r1            ; multiply by map width to get character offset in r2
       li   r1,map_buffer              ; get the map base address
       a    r2,r1                      ; add the character offset
       li   r4,24                      ; number of rows to copy
*      Decide which buffer to update
       mov  @frame,r0                  ; Read frame into register
       andi r0,1
       jeq  update_name_table_2
*      Copy to vdp ram buffer
       li   r0,name_table_0+8          ; VDP address
update_name_table_1:
       bl   @copy_row                  ; low character set
       ai   r0,32
       bl   @check_int
       dec  r4
       jne  update_name_table_1
       jmp  update_name_table_4
update_name_table_2:
       li   r0,name_table_1+8          ; VDP address
update_name_table_3:
       bl   @copy_row_hi
       ai   r0,32
       bl   @check_int
       dec  r4
       jne  update_name_table_3
update_name_table_4:
       .endproc
*// update_name_table

*********************************************************************
*
* Change scroll offset
*
change_scroll_offset:
       .proc
       mov  @scroll_dy,r0
       jeq  change_scroll_offset_2
       a    r0,@scroll_y
       mov  @scroll_y,r1
       ci   r1,scroll_max
       jle  change_scroll_offset_1
       li   r1,scroll_max
       mov  r1,@scroll_y
change_scroll_offset_1:
       mov  r0,r0
       jgt  change_scroll_offset_2
       andi r1,15
       jne  change_scroll_offset_2
       mov  @step_points,r1
       bl   @add_score
change_scroll_offset_2:
       .endproc
*// change_scroll_offset

*********************************************************************
*
* Animate windows
*
animate_windows:
       .proc
       mov  @windows_head_ptr,r3       ; List of window animations (including resident faces)
animate_windows_1:
       mov  r3,r3
       jeq  animate_windows_8          ; zero terminates
       mov  *r3+,r1                    ; Window y (row) (window_anim_row)
       mov  *r3+,r0                    ; Window x (0 - 5) (window_anim_col)
       bl   @window_map_addr           ; Map address in r2
       mov  *r3+,r5                    ; Get animation type (window_anim_type)
       mov  *r3,r4                     ; Get animation frame (window_anim_frame)
       sla  r4,1                       ; To word offset
       ci   r5,window_anim_type_resident ; Is it a face animation?
       jne  animate_windows_3          ; No - move on
       ai   r4,face_appear             ; Yes - add base address of face animations
       jmp  animate_windows_5
animate_windows_3:
       cb   @-map_width(r2),@b_window_closed_left_tch  ; Is window above closed?
       jeq  animate_windows_4          ; Yes - move on
       ai   r4,close_window_below_open ; No - add base address of closing windows below open animation
       jmp  animate_windows_5
animate_windows_4:
       ai   r4,close_window_below_closed ; Add base address of closing windows below closed animation
animate_windows_5:
       mov  *r4,r4                     ; Get address of animation bytes
       movb *r4+,*r2+                  ; Top row
       movb *r4+,*r2
       ai   r2,map_width-1             ; Next row
       movb *r4+,*r2+                  ; Middle row
       movb *r4+,*r2
       ai   r2,map_width-1             ; Next row
       movb *r4+,*r2+                  ; Bottom row
       movb *r4+,*r2
*      Update animation frame/count
       mov  *r3+,r4                    ; Get animation frame (window_anim_frame)
       dec  *r3                        ; Decrement count (window_anim_count)
       jne  animate_windows_5b         ; If not zero, don't update frame
       inc  r4                         ; Increment animation frame
       mov  r4,@-2(r3)                 ; Write frame back (window_anim_frame)
       mov  r4,r1
       sla  r1,1                       ; To word offset
       ci   r5,window_anim_type_resident ; Is it a face animation?
       jeq  animate_windows_5a
       mov  @close_window_counts(r1),*r3
       li   r2,4
       bl   @rand_max
       a    r0,*r3
       jmp  animate_windows_5b
animate_windows_5a:
       mov  @face_appear_counts(r1),*r3
animate_windows_5b:
       ai   r3,-window_anim_count      ; Back to base of record
*      Check for end of animation
       ci   r5,window_anim_type_resident ; Is it a face animation?
       jeq  animate_windows_6
*      Window animation
       ci   r4,10                      ; End at 10
       jeq  animate_windows_7
       jmp  animate_windows_2          ; Next window
*      Face animation
animate_windows_6:
       ci   r4,8                       ; End at 8
       jeq  animate_windows_7
       ci   r4,3                       ; Is it frame 4?
       jne  animate_windows_2          ; No - next window
       mov  @window_anim_count(r3),r0
       ci   r0,7
       jne  animate_windows_2
       bl   @create_resident           ; Create a new resident sprite
       jmp  animate_windows_2          ; Next window
*      Terminate animation
animate_windows_7:
       bl   @remove_window_from_list
*      Next
animate_windows_2:
       mov  @window_anim_next(r3),r3   ; Next window
       jmp  animate_windows_1
animate_windows_8:
       .endproc
*// animate_windows

*********************************************************************
*
* Remove window animation in r3 from list
*
* Modifies r1,r2
*
remove_window_from_list:
       c    @window_anim_type(r3),@w_window_anim_type_resident
       jne  remove_window_from_list_0
       dec  @current_residents
remove_window_from_list_0:
       clr  @window_anim_row(r3)       ; Clear y coord to mark as available
       mov  @window_anim_prev(r3),r1   ; Get previous
       mov  @window_anim_next(r3),r2   ; Get next
       jne  remove_window_from_list_1  ; Removing last? No - skip ahead
*      Removing last
       mov  r1,@windows_tail_ptr       ; tail = previous
       jeq  remove_window_from_list_2  ; Skip ahead if also first
       clr  @window_anim_next(r1)      ; previous.next = null
       jmp  remove_window_from_list_3  ; Return
remove_window_from_list_1:
*      Not last
       mov  r1,@window_anim_prev(r2)   ; next.previous = previous
       jeq  remove_window_from_list_2  ; Jump if first
*      Not first or last
       mov  r2,@window_anim_next(r1)   ; previous.next = next
       jmp  remove_window_from_list_3  ; Return
*      Removing first
remove_window_from_list_2:
       mov  r2,@windows_head_ptr       ; head = next
       jeq  remove_window_from_list_3  ; Return if last
       clr  @window_anim_prev(r2)      ; next.previous = null
remove_window_from_list_3:
       rt
*// remove_window_from_list

*********************************************************************
*
* Add window animation in r3 to list
*
* Modifies r1,r2
*
add_window_to_list:
       c    @window_anim_type(r3),@w_window_anim_type_resident
       jne  add_window_to_list_0
       inc  @current_residents
add_window_to_list_0:
       mov  @windows_head_ptr,r2       ; current = head
       jne  add_window_to_list_2
*      Add to empty list
       mov  r3,@windows_tail_ptr       ; tail = new
       clr  @window_anim_next(r3)      ; new.next = null
add_window_to_list_1:
*      Add first
       mov  r3,@windows_head_ptr       ; head = new
       clr  @window_anim_prev(r3)      ; new.previous = null
       jmp  add_window_to_list_5       ; Done
*      Not empty list
add_window_to_list_2:
       mov  r2,r2                      ; End of list?
       jeq  add_window_to_list_4       ; Yes - add at end
       c    *r3,*r2                    ; Compare y (window_anim_row) values
       jh   add_window_to_list_3       ; Still higher - proceed to next
*      Add in the middle or first      ; current.y >= new.y
       mov  r2,@window_anim_next(r3)   ; new.next = current
       mov  @window_anim_prev(r2),r1   ; previous = current.previous
       mov  r3,@window_anim_prev(r2)   ; current.previous = new
       mov  r1,r1                      ; previous == null?
       jeq  add_window_to_list_1       ; If null then adding first
       mov  r3,@window_anim_next(r1)   ; previous.next = new
       mov  r1,@window_anim_prev(r3)   ; new.previous = previous
       jmp  add_window_to_list_5       ; Done
add_window_to_list_3:
       mov  @window_anim_next(r2),r2   ; Next window
       jmp  add_window_to_list_2       ; Loop
*      Add at end
add_window_to_list_4:
       mov  @windows_tail_ptr,r2       ; tail
       mov  r3,@window_anim_next(r2)   ; tail.next = new
       mov  r2,@window_anim_prev(r3)   ; new.previous = tail
       clr  @window_anim_next(r3)      ; new.next = null
       mov  r3,@windows_tail_ptr       ; tail = new
add_window_to_list_5:
       rt
*// add_window_to_list

*********************************************************************
*
* Create window animations
*
create_windows:
       .proc
*      Remove window animations that are scrolled out
       mov  @scroll_y,r4
       srl  r4,4                       ; Number of windows scrolled
       ai   r4,12                      ; Y coord of bottom window row on screen
       mov  @windows_head_ptr,r3
create_windows_1:
       mov  r3,r3                      ; Reached the end?
       jeq  create_windows_3           ; Yes, move on
       c    r4,*r3                     ; Compare bottom row to window_anim_row
       jhe  create_windows_2           ; Skip ahead if bottom row is higher or equal
       bl   @remove_window_from_list   ; Bottom row is lower - remove window
create_windows_2:
       mov  @window_anim_next(r3),r3   ; Next window
       jmp  create_windows_1
create_windows_3:
*      Find an available slot to use
       li   r3,window_anims            ; Don't use linked list since we're looking for an empty slot
create_windows_4:
       mov  *r3,r1                     ; Window y (window_anim_row)
       jlt  create_windows_11           ; Negative is the end (no space)
       jeq  create_windows_5           ; Zero is unused
       ai   r3,window_anim_size
       jmp  create_windows_4
create_windows_5:
*      Add new window
*      Determine type
       c    @current_residents,@max_residents
       jhe  create_windows_6           ; Jump if resident not allowed
       bl   @rand
       andi r0,1                       ; 1/2 chance of resident
       ci   r0,window_anim_type_resident
       jeq  create_windows_7
create_windows_6:
       li  r0,window_anim_type_window
create_windows_7:
*      Set type
       mov  r0,@window_anim_type(r3)   ; 0 = empty window, 1 = resident
*      Determine position
       ci   r0,window_anim_type_resident
       jne  create_windows_7a
       mov  @current_residents,r0
       jne  create_windows_7a
       bl   @climber_column            ; X coord of climber
       jmp  create_windows_7b
create_windows_7a:
       li   r2,6                       ; X coord between 0 and 5
       bl   @rand_max                  ; X coord in r0
create_windows_7b:
       mov  r0,@window_anim_col(r3)    ; Write X coord
*      Y position
       li   r2,12                      ; Y coord between 0 and 11
       c    @window_anim_type(r3),@w_window_anim_type_resident
       jne  create_windows_7c
       ai   r2,-5                      ; Only add residents above climber
create_windows_7c:
       bl   @rand_max                  ; Y coord in r1
       ai   r4,-12                     ; Y coord of top window row on screen
       a    r4,r1                      ; Add y coord of top window row on screen
       mov  r1,*r3                     ; Save it in new window anim (window_anim_row)
*      Check map position
       mov  @window_anim_col(r3),r0    ; X coord
       bl   @window_map_addr           ; Window address in r2
       bl   @is_open_window            ; Is there an open window?
       jne  create_windows_10          ; If not then skip
       ai   r2,-2*map_width            ; Move one window up
       bl   @is_open_window_bottom     ; Is there an open window above?
       jne  create_windows_10          ; If not then skip
       ai   r2,4*map_width             ; Move one window down
       bl   @is_open_window            ; Is there an open window below?
       jne  create_windows_10          ; If not then skip
*      Other initializations
       clr  @window_anim_frame(r3)     ; Clear frame
       c    @window_anim_type(r3),@w_window_anim_type_resident
       jeq  create_windows_8
       mov  @close_window_counts,@window_anim_count(r3)
       jmp  create_windows_9
create_windows_8:
       mov  @face_appear_counts,@window_anim_count(r3)
create_windows_9:
*      Add new window to linked list sorted by y (row)
       bl   @add_window_to_list
       jmp  create_windows_11
create_windows_10:
*      Cancel adding window
       clr  *r3                        ; Make available again
create_windows_11:
       .endproc
*// create_windows

*********************************************************************
*
* Check grip
*
check_grip:
       .proc
       mov  @animation_count,r1        ; Is an animation count already taking place?
       jne  check_grip_4               ; Yes - return
*      Left
       clr  @left_grip
       clr  @left_hand_pos
       bl   @left_hand_y_offset
       mov  @scroll_y,r0
       ai   r0,-8
       a    r0,r1
       andi r1,>000f                   ; Hand position relative to building
       jne  check_grip_1
       bl   @left_hand_map_addr
       mov  r2,r4
       bl   @is_open_window_bottom
       jne  check_grip_1
       bl   @is_resident_above
       jeq  check_grip_1
       seto @left_grip
       bl   @left_hand_position
       mov  r1,@left_hand_pos
*      Right
check_grip_1:
       clr  @right_grip
       clr  @right_hand_pos
       bl   @right_hand_offset
       mov  @scroll_y,r0
       ai   r0,-8
       a    r0,r1
       andi r1,>000f                   ; Hand position relative to building
       jne  check_grip_2
       bl   @right_hand_map_addr
       mov  r2,r5
       bl   @is_open_window_bottom
       jne  check_grip_2
       bl   @is_resident_above
       jeq  check_grip_2
       seto @right_grip
       bl   @right_hand_position
       mov  r1,@right_hand_pos
*      Check if no grip
check_grip_2:
       mov  @left_grip,r0
       soc  @right_grip,r0
       jne  check_grip_4
*      No grip
       mov  r4,r2
       bl   @is_closed_window
       jne  check_grip_3
       mov  r5,r2
       bl   @is_closed_window
       jne  check_grip_3
       bl   @fall
       jmp  check_grip_4
check_grip_3:
       bl   @fall_short
check_grip_4:
       .endproc
*// check_grip

*********************************************************************
*
* Control climber vertically
*
control_climber_vert:
       .proc
       mov  @animation_count,r0        ; Is an animation count already taking place?
       jeq  control_climber_vert_check_keys ; Proceed if not
       b    @control_climber_vert_10   ; Branch to decrement counter
*      Check keys
control_climber_vert_check_keys:
       abs  @demo_mode
       jne  !
       bl   @check_vert_keys
       jmp  !!
!      bl   @demo_vert_keys
!      clr  @animation_changed
*      Control climber
       clr  @scroll_dy
*      Left side
       mov  @left_anim_ptr,r3          ; Get animation pointer
*      Check for left grip
       abs  @left_grip                 ; Does hand have grip?
       jeq  control_climber_vert_2     ; Skip ahead if not
*      Left grip
       ci   r3,left_anim_last          ; Is it the last animation frame?
       jeq  control_climber_vert_2     ; Skip ahead if so
       abs  r6                         ; Check down key
       jeq  control_climber_vert_2     ; Move on if not pressed
       ai   r3,spr_anim_size           ; Next frame
       mov  r3,@left_anim_ptr          ; Save new pointer
       li   r0,-2                      ; Scroll down 2 pixels
       mov  r0,@scroll_dy
       bl   @play_left_climbing_sound
       jmp  control_climber_vert_4
*      Check for right grip
control_climber_vert_2:
       abs  @right_grip                ; Does other hand have grip?
       jeq  control_climber_vert_3     ; Skip ahead if not
*      Right grip
       ci   r3,left_anim_last          ; Is it the last animation frame?
       jeq  control_climber_vert_3     ; Skip ahead if so
       abs  r6                         ; Check down key
       jeq  control_climber_vert_3     ; Move on if not pressed
       ai   r3,spr_anim_size           ; Next frame
       mov  r3,@left_anim_ptr          ; Save new pointer
       jmp  control_climber_vert_4
*      Not right grip
control_climber_vert_3:
       ci   r3,left_anim               ; Is it the first animation frame?
       jeq  control_climber_vert_5     ; Skip ahead if so
       abs  r7                         ; Check up key
       jeq  control_climber_vert_5     ; Move on if not pressed
       ai   r3,-spr_anim_size          ; Previous frame
       mov  r3,@left_anim_ptr          ; Save new pointer
control_climber_vert_4:
       bl   @update_climber_attrs_left
       mov  @w_2,@animation_count      ; Animation count = 2
       seto @animation_changed
*      Right
control_climber_vert_5:
       mov  @right_anim_ptr,r3          ; Get animation pointer
*      Check for right grip
       abs  @right_grip                ; Does hand have grip?
       jeq  control_climber_vert_6     ; Skip ahead if not
*      Right grip
       ci   r3,right_anim_last         ; Is it the last animation frame?
       jeq  control_climber_vert_6     ; Skip ahead if so
       abs  r8                         ; Check down key
       jeq  control_climber_vert_6     ; Move on if not pressed
       ai   r3,spr_anim_size           ; Next frame
       mov  r3,@right_anim_ptr         ; Save new pointer
       li   r0,-2                      ; Scroll down 2 pixels
       mov  r0,@scroll_dy
       bl   @play_right_climbing_sound
       jmp  control_climber_vert_8
*      Check for right grip
control_climber_vert_6:
       abs  @left_grip                 ; Does other hand have grip?
       jeq  control_climber_vert_7     ; Skip ahead if not
*      Left grip
       ci   r3,right_anim_last         ; Is it the last animation frame?
       jeq  control_climber_vert_7     ; Skip ahead if so
       abs  r8                         ; Check down key
       jeq  control_climber_vert_7     ; Move on if not pressed
       ai   r3,spr_anim_size           ; Next frame
       mov  r3,@right_anim_ptr         ; Save new pointer
       jmp  control_climber_vert_8
*      Not left grip
control_climber_vert_7:
       ci   r3,right_anim              ; Is it the first animation frame?
       jeq  control_climber_vert_9     ; Skip ahead if so
       abs  r9                         ; Check up key
       jeq  control_climber_vert_9     ; Move on if not pressed
       ai   r3,-spr_anim_size          ; Previous frame
       mov  r3,@right_anim_ptr         ; Save new pointer
control_climber_vert_8:
       bl   @update_climber_attrs_right
       mov  @w_2,@animation_count      ; Animation count = 2
       seto @animation_changed
control_climber_vert_9:
       abs  @animation_changed
       jeq  control_climber_vert_11
       clr  @inactivity_count
control_climber_vert_10:
       dec  @animation_count
control_climber_vert_11:
       .endproc
*// control_climber_vert

*********************************************************************
*
* Read vertical control keys
*
check_vert_keys:
       .proc
       mov  @control_set,r5
       clr  r6                         ; Check if the left joystick is moved left
       mov  @CTRL_LEFT_DN(r5),r0
       bl   @check_key
       jeq  check_vert_keys_1
       seto r6
check_vert_keys_1:
       clr  r7                         ; Check if the left joystick is moved right
       mov  @CTRL_LEFT_UP(r5),r0
       bl   @check_key
       jeq  check_vert_keys_2
       seto r7
check_vert_keys_2:
       clr  r8                         ; Check if the right joystick is moved left
       mov  @CTRL_RIGHT_DN(r5),r0
       bl   @check_key
       jeq  check_vert_keys_3
       seto r8
check_vert_keys_3:
       clr  r9                         ; Check if the right joystick is moved right
       mov  @CTRL_RIGHT_UP(r5),r0
       bl   @check_key
       jeq  check_vert_keys_4
       seto r9
check_vert_keys_4:
       .endproc
*// check_vert_keys

*********************************************************************
*
* Play left climbing sound
*
play_left_climbing_sound:
       .proc
       mov  @left_anim_ptr,r0
       ci   r0,left_anim_1
       jeq  play_left_climbing_sound_1
       ci   r0,left_anim_3
       jne  play_left_climbing_sound_2
play_left_climbing_sound_1
       bl   @play_left_hand
play_left_climbing_sound_2
       .endproc
*// play_left_climbing_sound

*********************************************************************
*
* Play right climbing sound
*
play_right_climbing_sound:
       .proc
       mov  @right_anim_ptr,r0
       ci   r0,right_anim_1
       jeq  play_right_climbing_sound_1
       ci   r0,right_anim_3
       jne  play_right_climbing_sound_2
play_right_climbing_sound_1
       bl   @play_right_hand
play_right_climbing_sound_2
       .endproc
*// play_right_climbing_sound

*********************************************************************
*
* Update right climber attributes
*
update_climber_attrs_left:
*      Update patterns
       mov  @left_anim_ptr,r3
       mov  @left_wide,r0
       jeq  update_climber_attrs_left_1
       ai   r3,4                       ; Move to wide patterns
update_climber_attrs_left_1:
       mov  *r3+,r1                    ; Pointer to top/bottom body sprite patterns
       movb *r1+,@sprite_attributes_body+2
       movb *r1,@sprite_attributes_body+10
       mov  *r3,r1                     ; Pointer to head/hands sprite pattern
       movb *r1+,@sprite_attributes_overlay+10
       movb *r1,@sprite_attributes_overlay+2
*      Update position
       mov  @climber_pos,r0
       mov  r0,@sprite_attributes_overlay+8
       mov  r0,@sprite_attributes_body
       ai   r0,>1000
       mov  r0,@sprite_attributes_overlay
       mov  r0,@sprite_attributes_body+8
       rt
*// update_climber_attrs_left

*********************************************************************
*
* Update right climber attributes
*
update_climber_attrs_right:
*      Update patterns
       mov  @right_anim_ptr,r3
       mov  @right_wide,r0
       jeq  update_climber_attrs_right_1
       ai   r3,4                       ; Move to wide patterns
update_climber_attrs_right_1:
       mov  *r3+,r1                    ; Pointer to top/bottom body sprite patterns
       movb *r1+,@sprite_attributes_body+6
       movb *r1,@sprite_attributes_body+14
       mov  *r3,r1                     ; Pointer to head/hands sprite pattern
       movb *r1+,@sprite_attributes_overlay+14
       movb *r1,@sprite_attributes_overlay+6
*      Update position
       mov  @climber_pos,r0
       ai   r0,>0010
       mov  r0,@sprite_attributes_overlay+12
       mov  r0,@sprite_attributes_body+4
       ai   r0,>1000
       mov  r0,@sprite_attributes_overlay+4
       mov  r0,@sprite_attributes_body+12
       rt
*// update_climber_attrs_right

*********************************************************************
*
* Control climber horizontally
*
control_climber_horz:
       .proc
       mov  @animation_count,r0        ; Is an animation count already taking place?
       jeq  control_climber_horz_check_keys
       b    @control_climber_horz_11   ; Skip ahead if so
*      Check keys
control_climber_horz_check_keys:
       abs  @demo_mode
       jne  !
       bl   @check_horz_keys
       jmp  !!
!      bl   @demo_horz_keys
!      clr  @animation_changed
*      Control climber
*      Check for auto movement left
       abs  r1
       jeq  auto_move_3
       abs  r3
       jeq  auto_move_3
*      Auto move left
       mov  @left_hand_pos,r0
       jgt  auto_move_1
       jlt  auto_move_2
*      Left hand at wall
       mov  @right_hand_pos,r0
       jgt  control_climber_horz_0a    ; Right hand at left side of window - make left wide
       jeq  auto_move_0                ; Right hand at wall (falling)
       cb   @climber_pos+1,@b_building_left
       jh   control_climber_horz_1a    ; Right hand at right side of window - make right wide and move
auto_move_0:
       b    @control_climber_horz_11
auto_move_1:
*      Left hand at left side of window
       mov  @right_hand_pos,r0
       jgt  control_climber_horz_8a    ; Right hand at left side of window - make left normal and move
       jlt  control_climber_horz_0a    ; Right hand at right side of window - make left wide
       abs  @left_wide
       jne  control_climber_horz_8a    ; Make left normal and move
       abs  @right_wide
       jeq  control_climber_horz_5a    ; Right hand at wall, right normal - make right wide
       jmp  control_climber_horz_7a    ; Right hand at wall, right wide - make right normal
auto_move_2:
*      Left hand at right side of window
       mov  @right_hand_pos,r0
       jlt  control_climber_horz_8a    ; Right hand at right side of window - make left normal and move
       jeq  control_climber_horz_5a    ; Right hand at wall - make right wide (bad position)
       abs @left_wide
       jne  control_climber_horz_1a    ; Right hand at left side of window, left wide - make right wide and move
       jmp  control_climber_horz_0a    ; Right hand at left side of window, left normal - make left wide
auto_move_3:
*      Check for auto movement right
       abs  r2
       jeq  control_climber_horz_0
       abs r4
       jeq  control_climber_horz_0
*      Auto move right
       mov  @right_hand_pos,r0
       jgt  auto_move_4
       jlt  auto_move_5
*      Right hand at wall
       mov  @left_hand_pos,r0
       jlt  control_climber_horz_5a      ; Left hand at right side of window - make right wide
       jeq  control_climber_horz_11      ; Left hand at wall (falling)
       cb   @climber_pos+1,@b_building_right
       jl   control_climber_horz_6a      ; Left hand at left side of window - make left wide and move
       jmp  control_climber_horz_11
auto_move_4:
*      Right hand at left side of window
       mov  @left_hand_pos,r0
       jgt  control_climber_horz_3a      ; Left hand at left side of window - make right normal and move
       jeq  control_climber_horz_0a      ; Left hand at wall - make left wide (bad position)
       abs  @right_wide
       jne  control_climber_horz_6a      ; Left hand at right side of window, right wide - make left wide and move
       jmp  control_climber_horz_5a      ; Left hand at right side of window, right normal - make right wide
auto_move_5:
*      Right hand at right side of window
       mov  @left_hand_pos,r0
       jgt  control_climber_horz_5a      ; Left hand at left side of window - make right wide
       jlt  control_climber_horz_3a      ; Left hand at right side of window - make right normal and move
       abs  @right_wide
       jne  control_climber_horz_3a      ; Make right normal and move
       abs  @left_wide
       jeq  control_climber_horz_0a      ; Left hand at wall, left normal - make left wide
       jmp  control_climber_horz_2a      ; Left hand at wall, left wide - make left normal
control_climber_horz_0:
*      Left
       abs  @right_grip                ; Can only move left arm if right hand has a grip
       jeq  control_climber_horz_5
       abs  @left_wide
       jne  control_climber_horz_1
*      Left is normal
       abs  r1                         ; S (1st)
       jeq  control_climber_horz_5
control_climber_horz_0a:
       seto @left_wide                 ; Make left wide
       jmp  control_climber_horz_4
*      Left is wide
control_climber_horz_1:
       abs  @right_wide
       jne  control_climber_horz_3
*      Left is wide and right is normal
       abs  r1                         ; S (2nd)
       jeq  control_climber_horz_2
control_climber_horz_1a:
       seto @right_wide                ; Make right wide
       li   r0,8                       ; Move 8 pixels left
       s    r0,@climber_pos
       jmp  control_climber_horz_9
control_climber_horz_2:
       abs r2                          ; F (2nd)
       jeq  control_climber_horz_5
control_climber_horz_2a:
       clr  @left_wide                 ; Make left normal
       jmp  control_climber_horz_4
*      Left is wide and right is wide
control_climber_horz_3:
       abs r2                          ; F (1st)
       jeq  control_climber_horz_5
control_climber_horz_3a:
       clr  @right_wide                ; Make right normal
       li   r0,8                       ; Move 8 pixels right
       a    r0,@climber_pos
       jmp  control_climber_horz_9
control_climber_horz_4:
       bl   @update_climber_attrs_left
       jmp  control_climber_horz_11
*      Right
control_climber_horz_5:
       abs  @left_grip                 ; Can only move right arm if left hand has a grip
       jeq  control_climber_horz_11
       abs  @right_wide
       jne  control_climber_horz_6
*      Right is normal
       abs  r4                         ; L
       jeq  control_climber_horz_11
control_climber_horz_5a:
       seto @right_wide                 ; Make right wide
       jmp  control_climber_horz_10
*      Right is wide
control_climber_horz_6:
       abs  @left_wide
       jne  control_climber_horz_8
*      Right is wide and left is normal
       abs  r4                         ; L
       jeq  control_climber_horz_7
control_climber_horz_6a:
       seto @left_wide                 ; Make left wide
       li   r0,8                       ; Move 8 pixels right
       a    r0,@climber_pos
       jmp  control_climber_horz_9
control_climber_horz_7:
       abs  r3                         ; J
       jeq  control_climber_horz_11
control_climber_horz_7a:
       clr  @right_wide                 ; Make right normal
       jmp  control_climber_horz_10
*      Right is wide and left is wide
control_climber_horz_8:
       abs  r3                         ; J
       jeq  control_climber_horz_11
control_climber_horz_8a:
       clr  @left_wide                 ; Make left normal
       li   r0,8                       ; Move 8 pixels left
       s    r0,@climber_pos
control_climber_horz_9:
       bl   @update_climber_attrs_left
control_climber_horz_10:
       bl   @update_climber_attrs_right
       clr  @inactivity_count
control_climber_horz_11:
       .endproc
*// control_climber_horz

*********************************************************************
*
* Read horizontal control keys
*
check_horz_keys:
       .proc
       mov  @control_set,r5
       clr  r1                         ; Check if the left joystick is moved left
       mov  @CTRL_LEFT_LT(r5),r0
       bl   @check_key
       jeq  check_horz_keys_1
       seto r1
check_horz_keys_1:
       clr  r2                         ; Check if the left joystick is moved right
       mov  @CTRL_LEFT_RT(r5),r0
       bl   @check_key
       jeq  check_horz_keys_2
       seto r2
check_horz_keys_2:
       clr  r3                         ; Check if the right joystick is moved left
       mov  @CTRL_RIGHT_LT(r5),r0
       bl   @check_key
       jeq  check_horz_keys_3
       seto r3
check_horz_keys_3:
       clr  r4                         ; Check if the right joystick is moved right
       mov  @CTRL_RIGHT_RT(r5),r0
       bl   @check_key
       jeq  check_horz_keys_4
       seto r4
check_horz_keys_4:
       .endproc
*// check_horz_keys

*********************************************************************
*
* Display climber sprites
*
display_climber_sprites:
       .proc
       bl   @display_climber_overlay
       li   r1,sprite_attributes_body
       li   r2,2
       clr  r3
       bl   @vm8bw_pad
       .endproc
*// display_climber_sprites

*********************************************************************
*
* Display climber head/hands overlay
*
display_climber_overlay:
       mov  @secondary_sprite_patterns,r0
       jne  display_climber_overlay_3
       movb @sprite_attributes_overlay+2,r0
       jeq  display_climber_overlay_1
       li   r0,sprite_attributes_overlay
       movb *r0+,*r15
       movb *r0+,*r15
       movb *r0+,*r15
       movb *r0+,*r15
display_climber_overlay_1:
       movb @sprite_attributes_overlay+6,r0
       jeq  display_climber_overlay_2
       li   r0,sprite_attributes_overlay+4
       movb *r0+,*r15
       movb *r0+,*r15
       movb *r0+,*r15
       movb *r0+,*r15
display_climber_overlay_2:
       li   r0,sprite_attributes_overlay+8
       movb *r0+,*r15
       movb *r0+,*r15
       movb *r0+,*r15
       movb *r0+,*r15
       movb *r0+,*r15
       movb *r0+,*r15
       movb *r0+,*r15
       movb *r0+,*r15
display_climber_overlay_3:
       rt
*// display_climber_overlay

*********************************************************************
*
* Handle other sprites
*
handle_other_sprites:
       .proc
       li   r3,sprites
handle_other_sprites_1:
       mov  *r3,r0                     ; sprite_handler
       jeq  handle_other_sprites_2
       bl   *r0
handle_other_sprites_2:
       ai   r3,sprite_size
       ci   r3,sprites_end
       jl   handle_other_sprites_1
       .endproc
*// handle_other_sprites

*********************************************************************
*
* Create plant
*
* r3 points to sprite structure of resident (must be preserved)
*
create_plant:
       .proc
       bl   @allocate_sprite
       mov  r4,r4
       jeq  create_plant_1
       li   r0,plant_handler
       mov  r0,@sprite_handler(r4)     ; sprite_handler
       mov  @sprite_x(r3),r0
       mov  @sprite_y(r3),r1
       bl   @window_screen_coords
       sla  r0,4
       mov  r0,@sprite_x(r4)           ; sprite_x
       sla  r1,4
       mov  r1,@sprite_y(r4)           ; sprite_y
       clr  @sprite_vx(r4)
       clr  @sprite_vy(r4)
       clr  @sprite_ax(r4)
       li   r0,>0003
       mov  r0,@sprite_ay(r4)
       clr  @sprite_count(r4)          ; sprite_count
create_plant_1:
       .endproc
*// create_plant

*********************************************************************
*
* Dropping plant handler
*
* r3: sprite structure
*
plant_handler:
       .proc
*      Display sprite
       mov  @sprite_y(r3),r1
       srl  r1,4
       dec  r1
       swpb r1
       movb r1,*r15
       mov  @sprite_x(r3),r0
       srl  r0,4
       swpb r0
       movb r0,*r15
       li   r2,spr_plant_1*256
       movb r2,*r15
       li   r2,>0c00                   ; Green
       movb r2,*r15
*      Check for collision with climber
       bl   @check_sprite_hit_head
       mov  r2,r2
       jeq  plant_handler_1
*      Hit
       mov  r1,r1                      ; X offset from climber
       jlt  !
       li   r2,->0008
       jmp  !!
!      li   r2,>0008
!      mov  r2,@sprite_vx(r3)
       mov  @sprite_vy(r3),r2
       neg  r2                         ; Reverse y velocity
       sra  r2,1
       mov  r2,@sprite_vy(r3)
       a    r2,@sprite_y(r3)           ; Prevent double hit
       .push r3
       bl   @lose_grip
       bl   @play_boing
       .pop  r3
       li   r0,8
       mov  r0,@sprite_count(r3)
       seto @speech_reserved
*      Update sprite
plant_handler_1:
       a    @sprite_ax(r3),@sprite_vx(r3)
       a    @sprite_ay(r3),@sprite_vy(r3)
       a    @sprite_vx(r3),@sprite_x(r3)
       a    @sprite_vy(r3),@sprite_y(r3)
       mov  @scroll_dy,r0
       sla  r0,4
       s    r0,@sprite_y(r3)
       c    @sprite_y(r3),@plant_bottom_screen
       jl   plant_handler_2
       clr  @sprite_handler(r3)
plant_handler_2:
       dec  @sprite_count(r3)
       jne  plant_handler_3
       clr  @speech_reserved
       li   r0,speech_ouch_idx
       bl   @speak
plant_handler_3:
       .endproc
plant_bottom_screen:
       data 194 * 16;
*// plant_handler

*********************************************************************
*
* Create resident
*
* r3 points to window structure (must be preserved)
*
create_resident:
       .proc
       bl   @allocate_sprite
       mov  r4,r4
       jeq  create_resident_1
       li   r0,resident_handler
       mov  r0,@sprite_handler(r4)     ; sprite_handler
       mov  @window_anim_row(r3),@sprite_y(r4)   ; sprite_y
       mov  @window_anim_col(r3),@sprite_x(r4)   ; sprite_x
       clr  @sprite_count(r4)          ; sprite_count
create_resident_1:
       .endproc
*// create_resident

*********************************************************************
*
* Resident person handler
*
* r3: sprite structure
*
resident_handler:
       .proc
       mov  @sprite_count(r3),r0       ; Init?
       jne  resident_handler_1         ; Jump if not
       li   r0,24
       mov  r0,@sprite_count(r3)
resident_handler_1:
       mov  @sprite_x(r3),r0
       mov  @sprite_y(r3),r1
       bl   @window_screen_coords
       mov  r1,r1
       jlt  resident_handler_3
       dec  r1
       swpb r1
       movb r1,*r15
       swpb r0
       movb r0,*r15
       li   r0,spr_resident*256
       movb r0,*r15
       li   r0,>0f00                   ; White
       movb r0,*r15
       c    @sprite_count(r3),@resident_handler_drop
       jne  resident_handler_2
       bl   @create_plant
resident_handler_2:
       dec  @sprite_count(r3)
       jne  resident_handler_3
       clr  @sprite_handler(r3)        ; Handler done
resident_handler_3:
       .endproc
resident_handler_drop:
       data 16
*// resident_handler

*********************************************************************
*
* Create bird dropping
*
* r3: Bird sprite
*
create_bird_dropping:
       .proc
       bl   @allocate_sprite
       mov  r4,r4
       jeq  create_bird_dropping_1
       li   r0,bird_dropping_handler
       mov  r0,@sprite_handler(r4)
       mov  @sprite_x(r3),r0
       ai   r0,16
       mov r0,@sprite_x(r4)
       mov  @sprite_y(r3),r0
       s    @scroll_y,r0
       ai   r0,16
       mov  r0,@sprite_y(r4)
       clr  @sprite_vx(r4)
       mov  @w_4,@sprite_vy(r4)
       bl   @rand
       jlt  create_bird_dropping_2
       li   r0,>9405                   ; Pattern and color
       jmp  create_bird_dropping_3
create_bird_dropping_2:
       li   r0,>980e                   ; Pattern and color
create_bird_dropping_3:
       mov  r0,@sprite_count(r4)
       inc  @bird_droppings
create_bird_dropping_1:
       .endproc
*// create_bird_dropping

*********************************************************************
*
* Bird dropping handler
*
bird_dropping_handler:
       .proc
*      Display sprite
       mov  @sprite_y(r3),r1
       swpb r1
       movb r1,*r15
       mov  @sprite_x(r3),r0
       swpb r0
       movb r0,*r15
       mov  @sprite_count(r3),r2
       movb r2,*r15
       swpb r2
       movb r2,*r15
*      Check for collision with climber
       bl   @check_sprite_hit_head
       mov  r2,r2
       jeq  bird_dropping_handler_2
*      Hit
       bl   @fall
       jmp  bird_dropping_handler_3
*      Update sprite
bird_dropping_handler_2:
       a    @sprite_vy(r3),@sprite_y(r3)
       mov  @sprite_y(r3),r0
       ci   r0,>00c0
       jl   bird_dropping_handler_4
bird_dropping_handler_3:
       clr  *r3
       dec  @bird_droppings
bird_dropping_handler_4:
       .endproc
*// bird_dropping_handler

*********************************************************************
*
* Check if sprite hit head of climber
*
* r0 MSB: sprite x in screen coordinates
* r1 MSB: sprite y in screen coordinates
*
* On return r2 is not zero if hit. r1 is x offset from climber.
*
check_sprite_hit_head:
       mov  @climber_pos,r2
       sb   r1,r2                      ; Climber y - plant y
       jlt  check_sprite_hit_head_2
       cb   r2,@b_12
       jgt  check_sprite_hit_head_2
       swpb r2
       abs  @left_wide
       jeq  check_sprite_hit_head_1
       ai   r2,>0800
check_sprite_hit_head_1:
       sb   r0,r2                      ; Climber x - plant x
       mov  r2,r1
       abs  r2
       cb   r2,@b_8
       jgt  check_sprite_hit_head_2
*      Hit
       seto r2
       rt
*      Not hit
check_sprite_hit_head_2:
       clr  r2
       rt
*// check_sprite_hit_head

*********************************************************************
*
* Base stage init
*
base_stage_init:
       .proc
       li   r1,head_and_hands_patterns
       bl   @load_sprite_patterns
       li   r1,character_set_door
       bl   @set_character_set
       clr  @max_residents
       .endproc
*// base_stage_init

*********************************************************************
*
* Copy door to map
*
* r0: Source address
* r1: Destination address in map
*
copy_door_to_map:
       li   r0,door_map
       li   r1,map_buffer+(418*map_width)+8
       li   r2,8                       ; Number of rows to copy
copy_door_to_map_1:
       movb *r0+,*r1+
       movb *r0+,*r1+
       movb *r0+,*r1+
       movb *r0+,*r1+
       movb *r0+,*r1+
       ai   r1,map_width-5
       dec  r2
       jne  copy_door_to_map_1
       rt
*// copy_door_to_map

*********************************************************************
*
* One resident stage init
*
one_resident_stage_init:
       .proc
       li   r1,character_set_residents
       bl   @set_character_set
       li   r0,1
       mov  r0,@max_residents
       .endproc
*// one_resident_stage_init

*********************************************************************
*
* Bird stage init
*
bird_stage_init:
       .proc
       li   r1,bird_patterns
       bl   @load_sprite_patterns
       clr  @max_residents
       bl   @allocate_sprite
       mov  r4,r4
       jeq  bird_stage_init_1
       li   r0,bird_init_data
       mov  *r0+,@sprite_handler(r4)
       mov  *r0+,@sprite_x(r4)
       mov  *r0+,@sprite_y(r4)
       mov  *r0+,@sprite_vx(r4)
       mov  *r0+,@sprite_vy(r4)
       mov  *r0+,@sprite_count(r4)
       clr  @bird_droppings
       clr  @bird_rounds
       li   r0,bird_module
       bl   @play_module
bird_stage_init_1:
       .endproc
*// bird_stage_init

*********************************************************************
*
* Bird handler
*
bird_handler:
       .proc
*      Remove
       mov  @status,r0
       jne  bird_handler_1
       c    @w_8,@bird_rounds
       jeq  bird_handler_1
       mov  @scroll_y,r0
       c    r0,@two_residents_stage
       jgt  bird_handler_2
bird_handler_1:
       clr  @sprite_handler(r3)
       bl   @mute_sound
       jmp  bird_handler_10
bird_handler_2:
*      Draw
       mov  @sprite_x(r3),r0
       mov  @sprite_y(r3),r1
       clr  r4
       mov  @sprite_count(r3),r5
       srl  r5,2
       div  @w_6,r4
       sla  r5,1
       mov  @sprite_vx(r3),r2
       jlt  bird_handler_3
       mov  @bird_right(r5),r4
       jmp  bird_handler_4
bird_handler_3:
       mov  @bird_left(r5),r4
bird_handler_4:
       bl   @draw_big_sprite
*      Move
       a    @sprite_vx(r3),@sprite_x(r3)
       a    @sprite_vy(r3),@sprite_y(r3)
       a    @scroll_dy,@sprite_y(r3)
*      X boundaries
       mov  @sprite_x(r3),r0
       ci   r0,>20
       jl   bird_handler_5
       ci   r0,>e0
       jle  bird_handler_6
bird_handler_5:
       neg  @sprite_vx(r3)
       a    @sprite_vx(r3),@sprite_x(r3)
       inc  @bird_rounds
bird_handler_6
*      Y boundaries
       mov  @sprite_y(r3),r0
       s    @scroll_y,r0
       jlt  bird_handler_7
       ci   r0,>18
       jle  bird_handler_8
bird_handler_7:
       neg  @sprite_vy(r3)
       a    @sprite_vy(r3),@sprite_y(r3)
bird_handler_8:
*      Drop
       mov  @bird_droppings,r0
       ci   r0,2
       jhe  bird_handler_9
       bl   @rand
       ci   r0,>f400
       jl   bird_handler_9
       bl   @create_bird_dropping
bird_handler_9:
       inc  @sprite_count(r3)
bird_handler_10:
       .endproc
bird_droppings:
       data 0
bird_rounds:
       data 0
*// bird_handler

*********************************************************************
*
* Two residents stage init
*
two_residents_stage_init:
       .proc
       bl   @mute_sound
       li   r1,head_and_hands_patterns
       bl   @load_sprite_patterns
       li   r0,2
       mov  r0,@max_residents
       .endproc
*// two_residents_stage_init

*********************************************************************
*
* Pre kong stage init
*
pre_kong_stage_init:
*      Stop residents before changing character set
       clr  @max_residents
       rt
*// pre_kong_stage_init

*********************************************************************
*
* Kong stage init
*
kong_stage_init:
       .proc
       li   r1,kong_patterns
       bl   @load_sprite_patterns
       clr  @max_residents
       li   r1,character_set_kong
       bl   @set_character_set
       bl   @allocate_sprite
       mov  r4,r4
       jeq  kong_stage_init_1
       li   r0,kong_init_data
       mov  *r0+,@sprite_handler(r4)
       mov  *r0+,@sprite_x(r4)
       mov  *r0+,@sprite_y(r4)
       mov  *r0+,@sprite_count(r4)
       mov  *r0+,@sprite_ax(r4)        ; Used to store current arms
       mov  *r0+,@sprite_ay(r4)        ; Used to store current side (left = 0, right <> 0)
       li   r0,kong_map
       li   r1,map_buffer+(kong_row*map_width)+3
       bl   @copy_kong_to_map
       li   r0,kong_module
       bl   @play_module
kong_stage_init_1:
       .endproc
*// kong_stage_init

*********************************************************************
*
* Kong handler
*
kong_handler:
       .proc
       mov  @scroll_y,r0
       s    @three_residents_stage,r0
       ci   r0,8
       jgt  kong_handler_1
       clr  @sprite_handler(r3)
       jmp  kong_handler_3
kong_handler_1:
       mov  @sprite_count(r3),r0
       andi r0,>001c
       swpb r0
       ai   r0,>a000
       movb r0,@kong+4
       mov  @sprite_x(r3),r0
       mov  @sprite_y(r3),r1
       li   r4,kong
       bl   @draw_big_sprite
       mov  @sprite_x(r3),r0
       mov  @sprite_y(r3),r1
       mov  @sprite_ay(r3),r4          ; Side 0 or 2
       mov  @kong_arms(r4),r4          ; Arms base
       mov  @sprite_ax(r3),r5          ; Arms 0-3
       sla  r5,1
       a    r5,r4
       mov  *r4,r4
       bl   @draw_big_sprite
*      Animate
       inc  @sprite_count(r3)
*      Animate arms
       mov  @sprite_count(r3),r0
       andi r0,>0007
       jne  kong_handler_3
       li   r2,4
       bl   @rand_max
       mov  r0,@sprite_ax(r3)          ; Current arms
*      Change side
       mov  @sprite_count(r3),r1
       andi r1,>003f
       jne  kong_handler_3
       mov  @sprite_count(r3),r1
       andi r1,>0040
       srl  r1,5
       mov  @kong_x(r1),@sprite_x(r3)
       mov  r1,@sprite_ay(r3)          ; Side
       jne  kong_handler_2
*      Remove right kong, draw left kong
       li   r0,kong_map_undraw
       li   r1,map_buffer+(kong_row*map_width)+14
       bl   @copy_kong_to_map
       li   r0,kong_map
       li   r1,map_buffer+(kong_row*map_width)+3
       bl   @copy_kong_to_map
       jmp  kong_handler_3
kong_handler_2:
*      Remove left kong, draw right kong
       li   r0,kong_map_undraw
       li   r1,map_buffer+(kong_row*map_width)+3
       bl   @copy_kong_to_map
       li   r0,kong_map
       li   r1,map_buffer+(kong_row*map_width)+14
       bl   @copy_kong_to_map
kong_handler_3:
*      Check for collision with climber
       c    @sprite_ax(r3),@w_3        ; Arm should be extended
       jne  kong_handler_4
       mov   @scroll_y,r0
       ci   r0,>03F0
       jhe  kong_handler_4
       ci   r0,>03D0
       jl   kong_handler_4
       bl   @climber_column
       mov  @sprite_ay(r3),r1          ; Side 0 or 2
       srl  r1,1                       ; 0 or 1
       inct r1                         ; 3 or 4
       c    r0,r1                      ; Compare to climber column
       jne  kong_handler_4
       bl   @fall
kong_handler_4:
       .endproc
kong_x:
       data >0058, >00b0
*// kong_handler

*********************************************************************
*
* Copy Kong to map
*
* r0: Source address
* r1: Destination address in map
*
copy_kong_to_map:
       li   r2,7                       ; Number of rows to copy
copy_kong_to_map_1:
       movb *r0+,*r1+
       movb *r0+,*r1+
       movb *r0+,*r1+
       movb *r0+,*r1+
       ai   r1,map_width-4
       dec  r2
       jne  copy_kong_to_map_1
       rt
*// copy_kong_to_map

*********************************************************************
*
* Three residents stage init
*
three_residents_stage_init:
       .proc
       bl   @mute_sound
*      Undraw kong
       li   r0,kong_map_undraw
       li   r1,map_buffer+(kong_row*map_width)+14
       bl   @copy_kong_to_map
       li   r0,kong_map_undraw
       li   r1,map_buffer+(kong_row*map_width)+3
       bl   @copy_kong_to_map
*      Restore characters and sprite patterns
       li   r1,character_set_residents
       bl   @set_character_set
       li   r1,head_and_hands_patterns
       bl   @load_sprite_patterns
       li   r0,3
       mov  r0,@max_residents
       .endproc
*// three_residents_stage_init

*********************************************************************
*
* Chopper stage init
*
chopper_stage_init:
       .proc
       li   r1,chopper_patterns
       bl   @load_sprite_patterns
       clr  @max_residents
       bl   @allocate_sprite
       mov  r4,r4
       jeq  chopper_stage_init_1
       li   r0,chopper_init_data
       mov  *r0+,@sprite_handler(r4)
       mov  *r0+,@sprite_x(r4)
       mov  *r0+,@sprite_y(r4)
       mov  *r0+,@sprite_count(r4)
       mov  *r0+,@sprite_vx(r4)
       mov  *r0+,@sprite_vy(r4)
chopper_stage_init_1:
       .endproc
*// chopper_stage_init

*********************************************************************
*
* Chopper handler
*
chopper_handler:
       .proc
       mov  @sprite_count(r3),r4
       ci   r4,480                     ; Give up?
       jne  chopper_handler_0
       inc  @status                    ; Yes, give up
       inc  @sprite_count(r3)
       jmp  chopper_handler_4
chopper_handler_0:
       mov  @sprite_x(r3),r0           ; Position of middle of landing gear
       mov  @sprite_y(r3),r1
       andi r4,1
       sla  r4,1
       mov  @sprite_vx(r3),r2
       jlt  !
       mov  @chopper_right(r4),r4
       ai   r0,->30
       jmp  !!
!      mov  @chopper_left(r4),r4
       ai   r0,->10
!      bl   @draw_big_sprite
*      Move
       inc  @sprite_count(r3)
       a    @sprite_vx(r3),@sprite_x(r3)
       a    @sprite_vy(r3),@sprite_y(r3)
*      Skip the rest if it's the end sequence
       mov  @status,r0
       jlt  chopper_handler_5
       jne  chopper_handler_6
*      Boundary check
       mov  @sprite_x(r3),r0
       ci   r0,>40
       jl   !
       ci   r0,>d8
       jh   !
       jmp  chopper_handler_1
!      neg  @sprite_vx(r3)
       a    @sprite_vx(r3),@sprite_x(r3)
chopper_handler_1:
       mov  @sprite_y(r3),r0
       jlt  !
       ci   r0,>54
       jh   !
       jmp  chopper_handler_2
!      neg  @sprite_vy(r3)
       a    @sprite_vy(r3),@sprite_y(r3)
chopper_handler_2:
*      Check for collision with climber
       c    @scroll_y,@w_8
       jne  chopper_handler_6
       mov  @sprite_y(r3),r0
       ci   r0,>50
       jlt  chopper_handler_6
       mov  @left_anim_ptr,r0
       ci   r0,left_anim
       jeq  chopper_handler_3
       mov  @right_anim_ptr,r0
       ci   r0,right_anim
       jne  chopper_handler_6
chopper_handler_3:
       mov  @sprite_x(r3),r0
       mov  @climber_pos,r1           ; TODO: Improve location of hand
       andi r1,>00ff
       ai   r1,>10
       s    r1,r0
       abs  r0
       ci   r0,>10
       jgt  chopper_handler_6
*      Pickup
chopper_handler_4:
       inc  @status
chopper_handler_5:
       clr  @sprite_vx(r3)
       seto @sprite_vy(r3)
chopper_handler_6:
       bl   @play_chopper
       .endproc
*// chopper_handler

*********************************************************************
*
* Allocate sprite
*
* Return sprite address in r4 or zero if no sprte available
*
allocate_sprite:
       li   r4,sprites
allocate_sprite_1:
       mov  *r4,*r4
       jeq  allocate_sprite_2
       ai   r4,sprite_size
       ci   r4,sprites_end
       jne  allocate_sprite_1
       clr  r4
allocate_sprite_2:
       rt
*// allocate_sprite

*********************************************************************
*
* Draw big sprite
*
* r0: x coordinate
* r1: y coordinate in world coordinates
* r4: Pointer to big sprite structure
*
draw_big_sprite:
       mov  *r4+,r2                    ; Number of small sprites
       swpb r0                         ; Move x to MSB
       s    @scroll_y,r1               ; To screen coordinates
       dec  r1
       ci   r1,-47
       jlt  draw_big_sprite_2
       swpb r1                         ; Move y to MSB
draw_big_sprite_1:
       ab   *r4+,r1                    ; Add y offset to oy
       movb r1,*r15
       ab   *r4+,r0                    ; Add x offset to x
       movb r0,*r15
       movb *r4+,*r15                  ; Pattern
       movb *r4+,*r15                  ; Color
       dec  r2
       jne  draw_big_sprite_1
draw_big_sprite_2:
       rt
*// draw_big_sprite

*********************************************************************
*
* Window column of climbers head
*
* On return r0 contains the column, r1 contains the offset in the column
*
climber_column:
       mov  @climber_pos,r1            ; y/x
       andi r1,>00ff                   ; x
       ai   r1,>0010->0050             ; Plus head offset, minus left position of building
       clr  r0                         ; For division
       div  @w_24,r0                   ; Row in r0
       rt
*// climber_column

*********************************************************************
*
* Position of climber's left hand in map
*
* On return r2 contains the address in the map
*
left_hand_map_addr:
       .proc
       mov  @climber_pos,r0
*      Y offset
       bl   @left_hand_y_offset
       inct r1
       swpb r1
       ab   r1,r0
*      X offset
       abs  @left_wide
       jne  left_hand_map_addr_1
       ai   r0,>0008
left_hand_map_addr_1:
       bl   @sprite_map_addr
       .endproc
*// left_hand_map_addr

*********************************************************************
*
* Y offset of climber's left hand
*
* On return r1 contains the offset
*
left_hand_y_offset:
       mov  @left_anim_ptr,r1
       ai   r1,-left_anim
       srl  r1,3
       sla  r1,2
       rt
*// left_hand_offset

*********************************************************************
*
* Left hand position
*
* On return r1 contains the position: -1=window right, 0=wall, 1=window left
*
left_hand_position:
       mov  @climber_pos,r1
       andi r1,>00ff                   ; x
       abs  @left_wide
       jne  left_hand_position_1
       ai   r1,>0008
left_hand_position_1:
       ai   r1,->0040                  ; Minus left position of building
       clr  r0
       div  @w_24,r0                   ; 0, 8, 16
       ai   r1,-8                      ; -8, 0, 8
       sra  r1,3                       ; -1, 0, 1
       rt
*// left_hand_position_1

*********************************************************************
*
* Position of climber's right hand in map
*
* On return r2 contains the address in the map
*
right_hand_map_addr:
       .proc
       mov  @climber_pos,r0
*      Y offset
       bl   @right_hand_offset
       inct r1
       swpb r1
       ab   r1,r0
*      X offset
       ai   r0,>0010
       abs  @right_wide
       jeq  right_hand_map_addr_1
       ai   r0,>0008
right_hand_map_addr_1:
       bl   @sprite_map_addr
       .endproc
*// right_hand_map_addr

*********************************************************************
*
* Y offset of climber's right hand
*
* On return r1 contains the offset
*
right_hand_offset:
       mov  @right_anim_ptr,r1
       ai   r1,-right_anim
       srl  r1,3
       sla  r1,2
       rt
*// left_hand_offset

*********************************************************************
*
* Right hand position
*
* On return r1 contains the position: -1=window right, 0=wall, 1=window left
*
right_hand_position:
       mov  @climber_pos,r1
       andi r1,>00ff                   ; x
       ai   r1,>0010
       abs  @right_wide
       jeq  right_hand_position_1
       ai   r1,>0008
right_hand_position_1:
       ai   r1,->0040                  ; Minus left position of building
       clr  r0
       div  @w_24,r0                   ; 0, 8, 16
       ai   r1,-8                      ; -8, 0, 8
       sra  r1,3                       ; -1, 0, 1
       rt
*// right_hand_position

*********************************************************************
*
* Map address at given screen coordinates
*
* r0: Screen coordinates of sprite y/x
*
* On return r2 contains the address in the map
*
sprite_map_addr:
       mov  r0,r1
       andi r0,>00ff                   ; x
       ai   r0,->0040                  ; Minus left position of building
       srl  r0,3                       ; To characters
       swpb r1
       andi r1,>00ff                   ; y
       inc  r1
       a    @scroll_y,r1
       srl  r1,3                       ; To character rows
       mpy  @w_map_width,r1            ; Multiply by map width
       a    r0,r2                      ; Add x
       ai   r2,map_buffer              ; Add base
       rt
*// sprite_map_addr

*********************************************************************
*
* Window address in map
*
* r0: window column
* r1: window row
*
* On return r2 contains the address in the map
*
window_map_addr:
       .push r1
       mpy  @w_map_width,r1            ; Multiply by map width to r2
       sla  r2,1                       ; Two rows per window
       ai   r2,map_buffer-map_width+2  ; Add address of start of map + offset for left wall
       a    r0,r2                      ; Add x to address x 1
       a    r0,r2                      ; Add x to address x 2
       a    r0,r2                      ; Add x to address x 3
       .pop r1
       rt
*// window_map_addr

*********************************************************************
*
* Window screen coordinates
*
* r0: window column
* r1: window row
*
* On return r0 and r1 contain the screen coordinates (x, y), r2 is modified
*
window_screen_coords:
       sla  r0,3                       ; column * 8
       mov  r0,r2
       sla  r0,1                       ; column * 16
       a    r2,r0                      ; column * 24
       ai   r0,>50                     ; Add offset from left
       sla  r1,4                       ; row * 16
       s    @scroll_y,r1               ; Minus scroll offsset
       rt
*// window_screen_coords

*********************************************************************
*
* Checks whether r2 points to a fully open window in the map
*
* On return EQ means that it's an open window. r1 is modified.
*
is_open_window:
       clr  r1
       movb *r2,r1
       swpb r1
       sla  r1,1
       a    @trans_chars,r1
       mov  *r1,r1
       cb   @b_window_open_top,r1
       rt
*// is_open_window

*********************************************************************
*
* Checks whether r2 points to a window with the bottom open in the map
*
* On return EQ means that it's an open window. r1 is modified.
*
is_open_window_bottom:
       clr  r1
       movb *r2,r1
       swpb r1
       sla  r1,1
       a    @trans_chars,r1
       mov  *r1,r1
       swpb r1
       cb   @b_window_open_bottom,r1
       rt
*// is_open_window_bottom

*********************************************************************
*
* Checks whether r2 points to a closed window in the map
*
* On return EQ means that it's a closed window. r1 is modified.
*
is_closed_window:
       clr  r1
       movb *r2,r1
       swpb r1
       sla  r1,1
       a    @trans_chars,r1
       mov  *r1,r1
       swpb r1
       cb   @b_window_left_bottom_closed,r1
       jeq  is_closed_window_1
       cb   @b_window_right_bottom_closed,r1
is_closed_window_1:
       rt
*// is_closed_window

*********************************************************************
*
* Checks whether r2 points to a window with a resident
*
* On return EQ means that there is a resident. r1 is modified.
*
is_resident_above:
       clr  r1
       movb @-map_width(r2),r1
       swpb r1
       sla  r1,1
       a    @trans_chars,r1
       mov  *r1,r1
       swpb r1
       cb   r1,@b_face_first
       jl   is_resident_above_1
       cb   r1,@b_face_last
       jh   is_resident_above_1
       cb   r1,r1                      ; Set EQ
is_resident_above_1:
       rt
*// is_resident_above

*********************************************************************
*
* Lose grip with one hand.
*
lose_grip:
       .proc
       abs  @left_grip
       jeq  lose_grip_3
       mov  @left_anim_ptr,r0
       ci   r0,left_anim
       jne  lose_grip_1
       ai   r0,spr_anim_size
       mov  r0,@left_anim_ptr
       bl   @update_climber_attrs_left
       jmp  lose_grip_6
lose_grip_1:
       ci   r0,left_anim_last
       jne  lose_grip_2
       ai   r0,-spr_anim_size
       mov  r0,@left_anim_ptr
       bl   @update_climber_attrs_left
       jmp  lose_grip_6
lose_grip_2:
       abs  @right_grip
       jeq  lose_grip_4
       mov  @right_anim_ptr,r0
       ci   r0,right_anim
       jne  lose_grip_3
       ai   r0,spr_anim_size
       mov  r0,@right_anim_ptr
       bl   @update_climber_attrs_right
       jmp  lose_grip_6
lose_grip_3:
       ci   r0,right_anim_last
       jne  lose_grip_4
       ai   r0,-spr_anim_size
       mov  r0,@right_anim_ptr
       bl   @update_climber_attrs_right
       jmp  lose_grip_6
lose_grip_4:
       bl   @fall
lose_grip_6:
       .endproc
*// lose_grip

*********************************************************************
*
* Fall
*
fall:
       .proc
       .ifeq falling_enabled,1
       dec  @status
       .else
       mov  @animation_count,r0
       jne  fall_1
       bl   @fall_short
fall_1:
       .endif
       li   r0,speech_oh_no_idx
       bl   @speak
       .endproc
*// fall

*********************************************************************
*
* Fall short
*
fall_short:
       mov  @w_2,@animation_count      ; Animation count = 2
       mov  @w_2,@scroll_dy            ; Lose grip
       rt
*// fall_short

*******************************************************************
*
* Display progress
*
display_progress:
       .proc
       mov  @frame,r0
       andi r0,63
       jeq  display_progress_2
       seto @title_bank_select
       mov  @climber_pos,r3            ; World y coordinate of climber
       srl  r3,8
       a    @scroll_y,r3
       srl  r3,4                       ; One pixel of progress per 16 lines of scrolling
       mov  r3,r4                      ; Save number of pixels
       srl  r3,3                       ; Number of characters from top
       mov  @progress_map,r1
       a    r3,r1
       movb *r1,r1                     ; Get character code
*      Copy pattern to buffer
       srl  r1,8
       ai   r1,-96
       sla  r1,3
       ai   r1,PAT96
       li   r0,buffer
       mov  *r1+,*r0+                  ; Copy 8 bytes
       mov  *r1+,*r0+
       mov  *r1+,*r0+
       mov  *r1+,*r0+
*      Copy colors to VDP
       li   r0,chr_prog*8+color_table
       ai   r1,COL96-PAT96-8
       li   r2,8
       bl   @vmbw
*      Update pattern buffer
       andi r4,7                       ; Pixel offset
       ai   r4,buffer
       movb *r4,r0
       li   r1,>1800
       xor  r1,r0
       movb r0,*r4
*      Copy pattern to VDP
       li   r0,chr_prog*8+pattern_table
       li   r1,buffer
       li   r2,8
       bl   @vmbw
       li   r0,chr_prog*8+pattern_table_1
       li   r1,buffer
       li   r2,8
       bl   @vmbw
       li   r0,chr_prog*8+pattern_table_2
       li   r1,buffer
       li   r2,8
       bl   @vmbw
*      Copy char to VDP
display_progress_0:
       mov  r3,r0                      ; Character offset
       s    @progress_top_offset,r0    ; Screen row for top of map
       ci   r0,3
       jgt  display_progress_1
       mov  @progress_top_offset,r1
       jeq  display_progress_1
       dec  @progress_top_offset
       bl   @display_progress_indicator
       jmp  display_progress_0
display_progress_1:
       sla  r0,5                       ; * 32
       ai   r0,name_table_0
       li   r1,chr_prog*256            ; Char 255
       bl   @vsbw
       ai   r0,name_table_1-name_table_0
       bl   @vsbw
*      Restore char below
       ai   r0,32                      ; Next row
       a    @progress_map,r3
       movb @1(r3),r1                  ; Next character
       bl   @vsbw
       ai   r0,name_table_0-name_table_1
       bl   @vsbw
       mov  @level_bank_select,r0
       seto *r0
display_progress_2:
       .endproc
*// display_progress

*******************************************************************
*
* Display progress indicator
*
display_progress_indicator:
       .proc
       li   r4,2
       li   r0,name_table_0
display_progress_indicator_1:
       mov  @progress_map,r1
       a    @progress_top_offset,r1
       li   r2,24
display_progress_indicator_2:
       bl   @vwad
       movb *r1+,*r15
       ai   r0,32
       dec  r2
       jne  display_progress_indicator_2
       li   r0,name_table_1
       dec  r4
       jne  display_progress_indicator_1
       .endproc
progress_top_offset:
       data 3
*// display_progress_indicator

*******************************************************************
*
* Add to score
*
* r1: Points to add
*
add_score:
       a    r1,@score
       jnc  add_score_1
       inc  @score_msw
add_score_1:
       rt
*// add_score

*******************************************************************
*
* Display score
*
display_score:
       .proc
       c    @score,@disp_score
       jeq  display_score_1
       mov  @score_msw,r6
       mov  @score,r7
       li   r0,32*6+2
       bl   @display_double
       mov  @score,@disp_score
display_score_1:
       .endproc
*// display_score

*******************************************************************
*
* Display high score
*
display_high_score:
       .proc
       mov  @high_scores,r6
       mov  @high_scores+2,r7
       li   r0,32*3+2
       bl   @display_double
       mov  @score,@disp_score
       .endproc
*// display_high_score

*******************************************************************
*
* Display bonus
*
update_and_display_bonus:
       .proc
       mov  @frame,r0
       andi r0,255
       ci   r0,255
       jne  update_and_display_bonus_1
       mov  @bonus,r1
       jeq  update_and_display_bonus_1
       ai   r1,-100
       mov  r1,@bonus
       bl   @display_bonus
update_and_display_bonus_1:
       .endproc
*// update_and_display_bonus

*******************************************************************
*
* Display bonus
*
display_bonus:
       .proc
       li   r0,32*18+2
       mov  @bonus,r1
       li   r2,5
       bl   @display_decimal
       .endproc
*// display_bonus

*******************************************************************
*
* Display step point
*
display_step_point:
       .proc
       li   r0,32*14+3
       mov  @step_points,r1
       li   r2,3
       bl   @display_decimal
       .endproc
*// display_step_point


*********************************************************************
*
* Display 2-word decimal number with 6 digits
*
* r0: Screen offset
* r6: MSW
* r7: LSW
*
display_double:
       .proc
       .push r0
       div  @w_10000,r6
       mov  r6,r1
       li   r2,2
       bl   @display_decimal
       .pop r0
       inct r0
       mov  r7,r1
       li   r2,4
       bl   @display_decimal
       .endproc
*// display_double

*********************************************************************
*
* Display decimal number
*
* r0: Screen offset
* r1: Number to display
* r2: Number of digits
*
display_decimal:
       .proc
       ai   r0,name_table_0
       mov  r0,r4
       bl   @vwad
       li   r5,buffer
       li   r3,5
       s    r2,r3
       sla  r3,1
       ai   r3,w_10000
       dec  r2
display_decimal_1:
       clr  r0
       div  *r3+,r0
       ai   r0,chr_zero
       swpb r0
       movb r0,*r15
       movb r0,*r5+
       dec  r2
       jne  display_decimal_1
       ai   r1,chr_zero
       swpb r1
       movb r1,*r15
       movb r1,*r5+
*      2nd name table buffer
       mov  r4,r0
       ai   r0,name_table_1-name_table_0
       li   r1,buffer
       mov  r5,r2
       ai   r2,-buffer
       bl   @vmbw
       .endproc
*// display_decimal

*******************************************************************
*
* Display lives
*
display_lives:
       .proc
*      Write to buffer
       li   r1,buffer
       li   r2,1
display_lives_1:
       c    @lives,r2
       jle  display_lives_2
       movb @b_life,*r1+
       jmp  display_lives_3
display_lives_2:
       movb @b_space,*r1+
display_lives_3:
       inc  r2
       ci   r2,6
       jle  display_lives_1
*      Display
       li   r0,22*32+2+name_table_0
       li   r1,buffer
       li   r2,6
       bl   @vmbw
       li   r0,22*32+2+name_table_1
       li   r1,buffer
       li   r2,6
       bl   @vmbw
       .endproc
*// display_lives

*********************************************************************
*
* Generate a pseudo random number within the given limit
*
* R2: Maximum number (0 - 255) exclusive
*
* On return r0 and r1 contains the number [0; R2[
*
rand_max:
       .proc
       bl   @rand                      ; generate a random number in r0
       andi r0,>00ff                   ; clear msb: [0-255]
       mpy  r2,r0                      ; width * [0-255]
       srl  r1,8                       ; (width * [0-255]) / 256
       mov  r1,r0                      ; copy result back
       .endproc
*// rand_max

*********************************************************************
*
* Generate a pseudo random number
*
* On return R0 contains the number, which is also stored at @RANDNO
*
* r0 and r1 are modified
*
rand:
       li   r0,28643                   ; A prime number to multiply by
       mpy  @rand_no,r0                ; Multiply by last random number
       ai   r1,31873                   ; Add a prime number
       src  r1,7                       ; Mix up the number to break odd/even pattern
       mov  r1,@rand_no                ; Save this number for next time
       mov  r1,r0
       rt
*// rand

*********************************************************************
*
* Display initial static screen
*
initial_static_screen:
       .proc
       bl   @load_static_characters
*      Name table 0
       li   r0,name_table_0
       li   r1,MD1
       li   r2,>300
       bl   @vmbw
*      Name table 1
       li   r0,name_table_1
       li   r1,MD1
       li   r2,>300
       bl   @vmbw
       .endproc
*// initial_static_screen

*********************************************************************
*
* Load non-scrolling characters
*
load_static_characters:
       .proc
       seto @title_bank_select
*      Non-scrolling patterns 1st part
       li   r0,96*8+pattern_table      ; Non-scrolling characters
       li   r1,PAT96
       li   r2,32*8
       bl   @vmbw
       li   r0,224*8+pattern_table     ; Non-scrolling characters
       li   r1,PAT224
       li   r2,32*8
       bl   @vmbw
*      Non-scrolling patterns 2nd part
       li   r0,96*8+pattern_table_1    ; Non-scrolling characters
       li   r1,PAT96
       li   r2,32*8
       bl   @vmbw
       li   r0,224*8+pattern_table_1    ; Non-scrolling characters
       li   r1,PAT224
       li   r2,32*8
       bl   @vmbw
*      Non-scrolling patterns 2rd part
       li   r0,96*8+pattern_table_2    ; Non-scrolling characters
       li   r1,PAT96
       li   r2,32*8
       bl   @vmbw
       li   r0,224*8+pattern_table_2    ; Non-scrolling characters
       li   r1,PAT224
       li   r2,32*8
       bl   @vmbw
*      Non-scrolling colors
       li   r0,96*8+color_table        ; Non-scrolling colors
       li   r1,COL96
       li   r2,32*8
       bl   @vmbw
       li   r0,224*8+color_table        ; Non-scrolling colors
       li   r1,COL224
       li   r2,32*8
       bl   @vmbw
       .endproc
*// load_static_characters

*********************************************************************
*
* Display initial scrolling screen
*
initial_scrolling_screen:
       .proc
       mov  @level_bank_select,r0
       seto *r0
       mov  @w_1,@frame
       bl   @update_pattern_table
       bl   @update_name_table
       clr  @frame
       bl   @set_name_table
*      Screen on
       li   r0,>01e2
       bl   @vwtr
       .endproc
*// initial_scrolling_screen

*********************************************************************
*
* Climber climbs the first few floors by himself
*
intro_climb:
       .proc
       bl   @base_stage_init
       li   r0,intro_module
       bl   @play_module
       li   r0,>9da8
       mov  r0,@climber_pos
       li   r8,3
intro_climb_1:
       li   r9,intro_climb_data
intro_climb_2:
       mov  *r9+,@left_anim_ptr
       mov  *r9+,@left_wide
       mov  *r9+,@right_anim_ptr
       mov  *r9+,@right_wide
       mov  *r9+,r7                    ; dy
       sb   r7,@climber_pos
       li   r6,4
intro_climb_3:
       bl   @vsync
       bl   @update_climber_attrs_left
       bl   @update_climber_attrs_right
       bl   @display_sprites
       bl   @int_routine
       dec  r6
       jne  intro_climb_3
       ci   r9,intro_climb_data_end
       jne  intro_climb_2
       dec  r8
       jne  intro_climb_1
*      Say go for it
       li   r0,speech_go_for_it_idx
       bl   @speak
       .endproc
intro_climb_data:
       data left_anim, 0, right_anim, 0, >0000
       data left_anim_1, 0, right_anim_1, 0, >0400
       data left_anim_2, 0, right_anim_2, 0, >0400
       data left_anim_3, 0, right_anim_3, 0, >0400
       data left_anim_4, 0, right_anim_4, 0, >0400
       data left_anim_4, 0, right_anim_4, 1, >0000
       data left_anim_4, 0, right_anim_3, 1, >0000
       data left_anim_4, 0, right_anim_2, 1, >0000
       data left_anim_4, 0, right_anim_1, 1, >0000
       data left_anim_4, 0, right_anim, 1, >0000
       data left_anim_4, 0, right_anim, 0, >0000
       data left_anim_4, 1, right_anim, 0, >0000
       data left_anim_3, 1, right_anim, 0, >0000
       data left_anim_2, 1, right_anim, 0, >0000
       data left_anim_1, 1, right_anim, 0, >0000
       data left_anim, 1, right_anim, 0, >0000
intro_climb_data_end:
       equ  $
*// intro_climb

*********************************************************************
*
* Climber is picked up by chopper
*
chopper_pickup:
       .proc
       c    @status,@w_1
       jne  chopper_pickup_0
       li   r0,completed_module
       bl   @play_module
chopper_pickup_0:
       li   r8,>90
chopper_pickup_1:
       li   r9,3
chopper_pickup_2:
       bl   @vsync
       bl   @int_routine
       dec  r9
       jne  chopper_pickup_2
       bl   @update_climber_attrs_left
       bl   @update_climber_attrs_right
       bl   @display_sprites
       mov  @bonus,r0
       jeq  chopper_pickup_3
       li   r1,100
       s    r1,r0
       mov  r0,@bonus
       bl   @add_score
       bl   @display_score
       bl   @display_bonus
chopper_pickup_3:
       c    @status,@w_1
       jne  chopper_pickup_4
       sb   @b_1,@climber_pos
chopper_pickup_4:
       inc  @frame
       dec  r8
       jne  chopper_pickup_1
       mov  @bonus,r1
       bl   @add_score
       bl   @disable_sprites
       .endproc
*// chopper_pickup

*********************************************************************
*
* Climber is falling from building
*
fall_sequence:
       .proc
fall_sequence_1:
       bl   @vsync
       bl   @int_routine
       bl   @update_climber_attrs_left
       bl   @update_climber_attrs_right
       bl   @display_sprites
       bl   @update_name_table
       ab   @b_1,@climber_pos
       cb   @climber_pos,@b_191
       jeq  fall_sequence_2
       inc  @frame
       jmp  fall_sequence_1
fall_sequence_2:
       .endproc
*// fall_sequence

*********************************************************************
*
* Scroll from bottom to last climber position
*
scroll_to_climber:
       .proc
       mov  @scroll_y,r9
       andi r9,>fff0
       ori  r9,>0008
       li   r0,scroll_max
       mov  r0,@scroll_y
       c    r0,r9
       jeq  scroll_to_climber_2
       li   r0,-8
       mov  r0,@scroll_dy
       clr  @frame
       bl   @update_pattern_table
scroll_to_climber_1:
       bl   @vsync
       bl   @set_name_table
       bl   @int_routine
       bL   @update_name_table
       a    @scroll_dy,@scroll_y
       mov  @scroll_y,r0
       inc  @frame
       c    r0,r9
       jh   scroll_to_climber_1
scroll_to_climber_2:
       .endproc
*// scroll_to_climber

*********************************************************************
*
* Display title screen
*
title_screen:
       .proc
title_screen_1:
       bl   @mute_sound
       seto @title_bank_select
       bl   @one_pattern_table
*      Title screen loop
       li   r0,3
       mov  r0,@title_screen_loops
title_screen_2:
       bl   @title_screen_main_cycle
       abs  @title_screen_done
       jne  title_screen_3
       dec  @title_screen_loops
       jne  title_screen_2
       bl   @demo_mode_screen
       bl   @one_pattern_table
       jmp  title_screen_1
title_screen_3:
*      Select name_table_0
       clr  @frame
       bl   @set_name_table
*      Screen off
       li   r0,>01a2
       bl   @vwtr
       bl   @three_pattern_tables
       .endproc
title_screen_loops:
       data 0
title_screen_done:
       data 0
*// title_screen

*********************************************************************
*
* Enable 3 pattern tables if required
*
one_pattern_table:
       .proc
       li   r0,>0400
       bl   @vwtr
       .endproc

*********************************************************************
*
* Enable 3 pattern tables if required
*
three_pattern_tables:
       .proc
       abs  @sprite_dupl_bug
       jeq  three_pattern_tables_1
*      3 pattern tables
       li   r0,>0403
       bl   @vwtr
three_pattern_tables_1:
       .endproc

*********************************************************************
*
* Display title screen
*
title_screen_main_cycle:
       .proc
*      Clear screen
       bl   @clear_screen
*      Display logo and text
       bl   @title_scroll_logo
       bl   @title_scroll_text
       li   r2,>8000
title_screen_main_cycle_1:
       bl   @check_int
*      Read keyboard
       li   r0,KEY_1
       bl   @check_key
       jeq  title_screen_main_cycle_2
       li   r0,keyboard_control
       mov  r0,@control_set
       jmp  title_screen_main_cycle_4
title_screen_main_cycle_2:
       li   r0,KEY_2
       bl   @check_key
       jeq  title_screen_main_cycle_3
       li   r0,joystick_control
       mov  r0,@control_set
       jmp  title_screen_main_cycle_4
title_screen_main_cycle_3:
       dec  r2
       jne  title_screen_main_cycle_1
       bl   @disable_sprites
       bl   @high_score_screen
       jmp  title_screen_main_cycle_5
title_screen_main_cycle_4:
       seto @title_screen_done
title_screen_main_cycle_5:
       .endproc
       data 0
*// title_screen

*********************************************************************
*
* Display scrolling logo
*
title_scroll_logo:
       .proc
       li   r0,55
       mov  r0,@scroll_y
*      Sprite patterns
       li   r0,sprite_pattern_table
       li   r1,T_SPR0
       li   r2,4*32
       bl   @vmbw
*      Main loop
title_scroll_logo_1:
       bl   @vsync
       bl   @set_name_table
       bl   @int_routine
*      Display sprites
       li   r0,sprite_attr_table
       bl   @vwad
       li   r1,T_SL0
       li   r2,4
       seto r3
       s    @scroll_y,r3
title_scroll_logo_2:
       clr  r0
       movb *r1+,@r0lb
       a    r3,r0
       swpb r0
       movb r0,*r15
       movb *r1+,*r15
       movb *r1+,*r15
       movb *r1+,*r15
       dec  r2
       jne  title_scroll_logo_2
       li   r1,>d000
       movb r1,*r15
*      Calculate VDP RAM destination offset
       mov  @frame,r4
       inv  r4
       andi r4,1
       sla  r4,10                      ; 0 or >400
*      Calculate cpu ram source address
       mov  @scroll_y,r5               ; Scroll offset
       andi r5,>0007                   ; Mod 8
       ai   r5,L_PSTRIP                ; Add base address of pattern strips
*      Copy patterns
       li   r0,pattern_table
       a    r4,r0
       mov  r5,r1
       mov  @L_TCHNUM,r2
       bl   @vm8bw8
*      Copy colors
       li   r0,color_table
       a    r4,r0
       mov  r5,r1
       ai   r1,L_CSTRIP-L_PSTRIP
       mov  @L_TCHNUM,r2
       bl   @vm8bw8
*      Copy name table
       mov  @frame,r0
       inv  r0
       andi r0,1
       jne  title_scroll_logo_3
       li   r0,name_table_0
       li   r1,7*32+L_MAP_LOW
       jmp  title_scroll_logo_4
title_scroll_logo_3:
       li   r0,name_table_1
       li   r1,7*32+L_MAP_HIGH
title_scroll_logo_4:
       li   r2,55
       s     @scroll_y,r2
       srl  r2,3
       sla  r2,5
       s    r2,r1
       srl  r2,3
       jeq  title_scroll_logo_5
       bl   @vm8bw
*      Change scroll offset
title_scroll_logo_5:
       dec  @scroll_y
       jlt  title_scroll_logo_6
       inc  @frame
       jmp  title_scroll_logo_1
title_scroll_logo_6:
       li   r0,name_table_0
       li   r1,L_MAP_HIGH+32
       li   r2,6*32/8
       bl   @vm8bw
       .endproc
*// title_scroll_logo

*********************************************************************
*
* Display scrolling text
*
title_scroll_text:
       .proc
       clr  @scroll_y
*      Main loop
title_scroll_text_1:
       bl   @vsync
       bl   @set_name_table
       bl   @int_routine
*      Calculate VDP RAM destination offset
       mov  @frame,r4
       inv  r4
       andi r4,1
       sla  r4,10                      ; 0 or >400
*      Calculate cpu ram source address
       mov  @scroll_y,r5               ; Scroll offset
       andi r5,>0007                   ; Mod 8
       ai   r5,T_PSTRIP                ; Add base address of pattern strips
*      Copy patterns
       li   r0,58*8+pattern_table
       a    r4,r0
       mov  r5,r1
       mov  @T_TCHNUM,r2
       bl   @vm8bw8
*      Copy colors
       li   r0,58*8+color_table
       a    r4,r0
       mov  r5,r1
       ai   r1,T_CSTRIP-T_PSTRIP
       mov  @T_TCHNUM,r2
       bl   @vm8bw8
*      Copy name table
       mov  @frame,r0
       inv  r0
       andi r0,1
       jne  title_scroll_text_2
       li   r0,name_table_0+>300
       li   r1,T_MAP_LOW
       jmp  title_scroll_text_3
title_scroll_text_2:
       li   r0,name_table_1+>300
       li   r1,T_MAP_HIGH
title_scroll_text_3:
       mov  @scroll_y,r2
       srl  r2,3
       sla  r2,5
       s    r2,r0
       srl  r2,3
       jeq  title_scroll_text_4
       bl   @vm8bw
*      Change scroll offset
title_scroll_text_4:
       inct @scroll_y
       mov  @scroll_y,r0
       ci   r0,140
       jeq  title_scroll_text_5
       inc  @frame
       jmp  title_scroll_text_1
title_scroll_text_5:
       .endproc
*// title_scroll_text

*********************************************************************
*
* Display high score screen
*
high_score_screen:
       .proc
       bl   @clear_screen
       bl   @load_static_characters
       li   r0,color_table
       li   r1,>f100
       li   r2,>800
       bl   @vsmw
       clr  @frame
       bl   @set_name_table
       li   r0,5*32+9+name_table_0
       li   r1,txt_highest_scores
       li   r2,14
       bl   @vmbw
       li   r8,high_scores
       clr   r9
high_score_screen_1:
       mov  r9,r0
       sla  r0,6
       ai   r0,8*32+11
       ai   r0,name_table_0
       mov  r9,r1
       ai   r1,chr_zero
       inc  r1
       swpb r1
       movb r1,@txt_no1+2
       li   r1,txt_no1
       li   r2,4
       bl   @vmbw
       mov  r9,r0
       sla  r0,6
       ai   r0,8*32+15
       mov  *r8+,r6
       mov  *r8+,r7
       bl   @display_double
       inc  r9
       ci   r9,5
       jne  high_score_screen_1
       li   r2,>8000
high_score_screen_2:
       bl   @check_int
*      Read keyboard
       li   r0,KEY_1
       bl   @check_key
       jne  high_score_screen_3
       li   r0,KEY_2
       bl   @check_key
       jne  high_score_screen_3
       dec  r2
       jne  high_score_screen_2
high_score_screen_3:
       .endproc
*// high_score_screen

*********************************************************************
*
* Record high score
*
record_high_score:
       .proc
       li   r0,high_scores
       li   r2,5
record_high_score_1:
       c    @score_msw,*r0+
       jh   record_high_score_2
       c    @score,*r0
       jh   record_high_score_2
       inct r0
       dec  r2
       jne  record_high_score_1
       jmp  record_high_score_5
*      New high score
record_high_score_2:
       dect r0
       li   r1,high_scores_2nd_last
       c    r0,r1
       jh   record_high_score_4
       li   r3,high_scores_last
record_high_score_3:
       mov  *r1+,*r3+
       mov  *r1,*r3
       ai   r1,-6
       ai   r3,-6
       c    r1,r0
       jhe  record_high_score_3
record_high_score_4:
       mov  @score_msw,*r0+
       mov  @score,*r0
record_high_score_5:
       .endproc
*// record_high_score

*********************************************************************
*
* Display demo mode screen
*
demo_mode_screen:
       .proc
       seto @demo_mode
       bl   @three_pattern_tables
       bl   @initial_static_screen
       bl   @game_init
       bl   @level_init
       bl   @intro_climb
       bl   @restart_init
       clr  @frame
demo_loop:
       bl   @main_loop_body
       mov  @status,r0
       jlt  demo_loop_1
       li   r0,KEY_1
       bl   @check_key
       jne  demo_loop_1
       li   r0,KEY_2
       bl   @check_key
       jne  demo_loop_1
       inc  @frame
       mov  @frame,r0
       ci   r0,2000
       jne  demo_loop
demo_loop_1:
       clr  @demo_mode
       .endproc
*// demo_mode_screen

*********************************************************************
*
* Demo mode vertical control
*
* On return:
* r6 Left down
* r7 Left up
* r8 Right down
* r9 Right up
*
demo_vert_keys:
       mov  @frame,r0
       andi r0,8
       jeq  demo_vert_keys_1
       clr  r6
       clr  r7
       clr  r8
       clr  r9
       inc  @frame
       jmp  demo_vert_keys_2
demo_vert_keys_1:
       mov  @frame,r0
       andi r0,16
       mov  r0,r7                      ; Left up
       mov  r0,r8                      ; Right down
       li   r1,16
       xor  r1,r0
       mov  r0,r6                      ; Left down
       mov  r0,r9                      ; Right up
demo_vert_keys_2:
       rt
*// demo_vert_keys

*********************************************************************
*
* Demo mode horizontal control
*
* On return:
* r1 Left left
* r2 Left right
* r3 Right left
* r4 Right right
*
demo_horz_keys:
       clr  r1                         ; Left left
       clr  r2                         ; Left right
       clr  r3                         ; Right left
       clr  r4                         ; Right right
       rt
*// demo_horz_keys

*********************************************************************
*
* One time initializations
*
one_time_init:
       .proc
       li   r15,vdpwd
       li   r0,1
       mov  r0,@w_1
       li   r0,2
       mov  r0,@w_2
       mov  @>83c0,r1                  ; Random number seed
*      Clear scratchpad
       li   r0,padvar
       li   r2,pad_max-padvar
       bl   @clear
*      Randomize
       mov  r1,@rand_no
*      Copy code to scratchpad
       li   r0,vm8bw1
       li   r1,vm8bw_pad
       li   r2,vm8bw1_end-vm8bw1
       bl   @copy
       bl   @copy_speech_read_to_pad
*      Detect speech
       bl   @speech_check
*      Detect F18A
       bl   @f18a_detect
*      Setup graphics mode
       bl   @graphics_mode             ; call setup routine
*      Default values
       li   r0,keyboard_control
       mov  r0,@control_set
       .endproc
*// one_time_init

*********************************************************************
*
* Game initializations
*
game_init:
       .proc
*      Sprite patterns
       li   r0,sprite_pattern_table
       li   r1,SPR0
       li   r2,64*32
       bl   @vmbw
*      Game variables
       clr  @score
       clr  @score_msw
       clr  @status
       li   r0,3
       mov  r0,@lives
       li   r0,start_level
       mov  r0,@level
*      High score
       bl   @display_high_score
       .endproc
*// game_init

*********************************************************************
*
* Level initializations
*
level_init:
       .proc
       bl   @mute_sound
       bl   @clear_sprites_and_animations
*      Copy level data
       mov  @level,r0
       sla  r0,1
       ai   r0,levels
       mov  *r0,r0
       li   r1,current_level_data
       li   r2,level_data_size
       bl   @copy
*      Set ROM bank
       mov  @level_bank_select,r0
       seto *r0
*      Stage
       bl   @base_stage_init
       mov  @stages,r0
       mov  r0,@next_stage_ptr
*      Initial screen
       li   r0,scroll_max              ; Start at the bottom of the map
       mov  r0,@scroll_y
       li   r0,3                       ; Progress indicator
       mov  r0,@progress_top_offset
       seto  @disp_score               ; Score, bonus, step point
       mov  @bonus_points,@bonus
       bl   @display_bonus
       bl   @display_step_point
       bl   @display_progress_indicator
       .ifeq test_bird,1
       li   r0,>988                    ; For testing bird
       mov  r0,@scroll_y
       li   r0,bird_stage
       mov  r0,@next_stage_ptr
       .endif
       .ifeq test_kong,1
       li   r0,>4A8                    ; For testing kong
       mov  r0,@scroll_y
       li   r0,kong_stage
       mov  r0,@next_stage_ptr
       .endif
       .ifeq test_chopper,1
       li   r0,>088                    ; For testing chopper
       mov  r0,@scroll_y
       li   r0,chopper_stage
       mov  r0,@next_stage_ptr
       .endif
       bl   @unpack_map                ; Map
       bl   @copy_door_to_map
       bl   @initial_scrolling_screen
*      Place climber
       li   r0,initial_climber_position
       mov  r0,@climber_pos
       .endproc
*// level_init

*********************************************************************
*
* Restart initializations
*
restart_init:
       .proc
       bl   @display_lives
       bl   @clear_sprites_and_animations
*      Check if climber died
       mov  @status,r0
       jeq  restart_init_1
       jgt  restart_init_1
*      Actions after dying
       bl   @unpack_map
       bl   @scroll_to_climber
       clr  @max_residents
       mov  @next_stage_ptr,r0
       jne  restart_init_1
       bl   @chopper_stage_init
restart_init_1:
       clr  @status
       clr  @scroll_dy
*      Restare climber
       li   r0,initial_climber_position
       movb r0,@climber_pos            ; Only reset y
       li   r0,left_anim
       mov  r0,@left_anim_ptr
       clr  @left_wide
       bl   @update_climber_attrs_left
       li   r0,right_anim
       mov  r0,@right_anim_ptr
       clr  @right_wide
       bl   @update_climber_attrs_right
       .endproc
*// restart_init

*********************************************************************
*
* Clear sprites and animations
*
clear_sprites_and_animations:
       .proc
*      Clear sprites table
       li   r0,sprites
       li   r2,sprites_end-sprites
       bl   @clear
*      Clear window animations table and pointers
       li   r0,window_anims
       li   r2,window_anims_end-window_anims
       bl   @clear
       clr  @windows_head_ptr
       clr  @windows_tail_ptr
*      No residents
       clr  @current_residents
       .endproc
*// clear_sprites_and_animations

*********************************************************************
*
* Upload secondary sprite patterns to VDP
*
* r1: Set to load
*
load_sprite_patterns:
       .proc
       li   r0,sprite_pattern_table + (40 * 32)
       bl   @vwad
       mov  r1,@secondary_sprite_patterns
       sla  r1,1
       mov  @sprite_pattern_sets(r1),r1
       li   r2,24*32/8
       bl   @vdp_copy
       .endproc
*// load_sprite_patterns

*********************************************************************
*
* Set scroll character set
*
* r1: Set to load
*
set_character_set:
       mov  *r1+,@base_scroll_chars
       mov  *r1+,@extra_scroll_chars
       mov  *r1+,@vdp_base_of_extra_scroll_chars
       mov  *r1+,@cpu_offset_to_extra_scroll_chars
       rt
*// set_character_set

*********************************************************************
*
* Set graphics mode
*
graphics_mode:
       .proc
       clr  r0
       abs  @sprite_dupl_bug
       jne  graphics_mode_0
       movb r0,@vdp_registers+4        ; One pattern table
graphics_mode_0:
       li   r1,vdp_registers
       li   r2,8
graphics_mode_1:
       movb *r1+,@r0lb
       bl   @vwtr                      ; Set register
       ai   r0,>0100
       dec  r2
       jne  graphics_mode_1
*      Clear VDP RAM
       clr  r0
       clr  r1
       li   r2,>4000
       bl   @vsmw
*      Disable sprites
       bl   @disable_sprites
       .endproc
*      VDP registers
vdp_registers:
       byte >02                        ; Graphics II mode
       byte >e2                        ; 16K, display on, interrupt
       byte name_table_0/>400          ; Name table
       byte >9f                        ; Color table
       byte pattern_table/>800+>03     ; Pattern table x 3
       byte sprite_attr_table/>80      ; Sprite attribute table
       byte sprite_pattern_table/>800  ; Sprite pattern table
       byte >01                        ; Backdrop color
*// graphics_mode

********************************************************************************
*
* F18A detection
*
f18a_detect:
       .proc
*	   F18A Unlock
	   li   r0,>391C                   ; VR1/57, value 00011100
	   bl   @vwtr                      ; Write once
	   bl   @vwtr                      ; Write twice, unlock
*	   Check the version status reg
	   movb	@vdpsta,r0                 ; Clear status
	   li	r0,>0F01                   ; Set to read reg 1, Identity
	   bl   @vwtr
	   movb	@vdpsta,r0
	   andi	r0,>F000
	   ci	r0,>E000
	   jne	f18a_detect_1
	   clr	@sprite_dupl_bug           ; F18A - no sprite duplication bug
	   li	r0,>0F00                   ; Set to read reg 0
	   bl   @vwtr
	   jmp	f18a_detect_2
f18a_detect_1:
       seto	@sprite_dupl_bug            ; No F18A - assume sprite duplication bug is present
f18a_detect_2:
       .endproc
*// f18a_detect

*********************************************************************
*
* Clear screen
*
clear_screen
       .proc
       li   r0,name_table_0
       clr  r1
       li   r2,>700                    ; Clear two names tables
       bl   @vsmw
       .endproc
*// clear_screen

*********************************************************************
*
* Disable sprites
*
disable_sprites
       .proc
       li   r0,sprite_attr_table
       li   r1,>d000
       bl   @vsbw
       .endproc
*// disable_sprites

*********************************************************************
*
* Unpack map to RAM
*
unpack_map:
       .proc
       li   r0,map_buffer              ; Destination
       mov  @map_row_index,r1          ; Source index
       mov  @w_map_height,r4
unpack_map_1:
       clr  r2
       movb *r1+,r2                    ; Map row index
       swpb r2
       mpy  @w_map_width,r2            ; Offset in r3
       a    @map_rows,r3
       li   r2,map_width
unpack_map_2:
       movb *r3+,*r0+
       movb *r3+,*r0+
       dect r2
       jne  unpack_map_2
       dec  r4
       jne  unpack_map_1
       .endproc
*// unpack_map

*********************************************************************
*
* Clear CPU memory
*
clear:
       clr  *r0+
       dect r2
       jne  clear
       rt
*// clear

*********************************************************************
*
* Copy CPU memory
*
copy:
       mov  *r0+,*r1+
       dect r2
       jne  copy
       rt
*// copy

***************************************************************************
*
* Check key
*
* r0: Column in MSB: >0000 - >0700, Row in LSB: >0006 - >0014
*
*       Column   0      1    2    3    4    5     6       7
*     Row
*     >0006      =      .    ,    M    N    /    Fire    Fire
*     >0008    Space    L    K    J    H    ;    Left    Left
*     >000A    Enter    O    I    U    Y    P    Right   Right
*     >000C             9    8    7    6    0    Down    Down
*     >000E    Fctn     2    3    4    5    1    Up      Up
*     >0010    Shift    S    D    F    G    A
*     >0012    Ctrl     W    E    R    T    Q
*     >0014             X    C    V    B    Z
*
* On return NEQ means that the key is pressed
*
KEY_FI EQU  >0606
KEY_LF EQU  >0608
KEY_RG EQU  >060A
KEY_DN EQU  >060C
KEY_UP EQU  >060E
KEY_CM EQU  >0206
KEY_FS EQU  >0106
KEY_0  EQU  >050C
KEY_1  EQU  >050E
KEY_2  EQU  >010E
KEY_3  EQU  >020E
KEY_4  EQU  >030E
KEY_5  EQU  >040E
KEY_6  EQU  >040C
KEY_7  EQU  >030C
KEY_8  EQU  >020C
KEY_9  EQU  >010C
KEY_A  EQU  >0510
KEY_B  EQU  >0414
KEY_C  EQU  >0214
KEY_D  EQU  >0210
KEY_E  EQU  >0212
KEY_F  EQU  >0310
KEY_G  EQU  >0410
KEY_H  EQU  >0408
KEY_I  EQU  >020A
KEY_J  EQU  >0308
KEY_K  EQU  >0208
KEY_L  EQU  >0108
KEY_M  EQU  >0306
KEY_N  EQU  >0406
KEY_O  EQU  >010A
KEY_P  EQU  >050A
KEY_Q  EQU  >0512
KEY_R  EQU  >0312
KEY_S  EQU  >0110
KEY_T  EQU  >0412
KEY_U  EQU  >030A
KEY_V  EQU  >0314
KEY_W  EQU  >0112
KEY_X  EQU  >0114
KEY_Y  EQU  >040A
KEY_Z  EQU  >0514
KEY_SP EQU  >0008
KEY_EN EQU  >000A
KEY_FN EQU  >000E
KEY_SH EQU  >0010
KEY_CT EQU  >0012
JOY_FI EQU  >0606
JOY_LT EQU  >0608
JOY_RT EQU  >060A
JOY_DN EQU  >060C
JOY_UP EQU  >060E
JO2_LT EQU  >0708
JO2_RT EQU  >070A
JO2_DN EQU  >070C
JO2_UP EQU  >070E
*
check_key:
       li   r12,>0024                  ; CRU address of the column decoder
       ldcr r0,3                       ; Select column
       andi r0,>00ff
       mov  r0,r12                     ; Select row
       tb   0                          ; Test key, EQ if not pressed
       rt
*// check_key

***************************************************************************
*
* Check quit
*
check_quit:
       clr  r1                         ; Test column 0
       li   r12,>0024                  ; Address for column selection
       ldcr r1,3                       ; Select column
       li   r12,>0006                  ; Address to read rows
       stcr r1,8
       andi r1,>1100
       jeq  quit
*      Return
       rt
*      Quit
quit:
       clr  @>83c4                     ; Reset user ISR address
       seto @>6000                     ; Select first ROM bank
       blwp @>0000
*// check_quit

***************************************************************************
*
lower_memory_max:
       equ  $



*********************************************************************
*
*      Upper memory
*
       aorg >A000

*********************************************************************
*
*      Program includes
*
       copy "vdp.a99"
       copy "sound-player.a99"
       copy "music-player.a99"
       copy "sound-fx-routines.a99"
       copy "speech.a99"

*********************************************************************
*
*       Data
*

b_window_closed_left_tch:              ; Window left bottom closed -> Window left closed 5
       byte >21
b_window_open_top:                     ; Original window open top char
       byte chr_window_open_top
b_window_open_bottom:                  ; Original window open bottom char
       byte chr_window_open_bottom
b_window_left_bottom_closed:           ; Original Window left bottom closed char
       byte chr_window_left_bottom_closed
b_window_right_bottom_closed:          ; Original Window right bottom closed char
       byte chr_window_right_bottom_closed
b_face_first:
       byte chr_face_first
b_face_last:
       byte chr_face_last
b_building_left:
       byte >40
b_building_right:
       byte >c8
b_life:
       byte chr_life
b_space:
       byte chr_space
b_1:
       byte 1
b_8:
       byte 8
b_12:
       byte 12
b_191:
       byte 191
b_192:
       byte 192
w_0:
       data 0
w_1:
       data 1
w_2:
       data 2
w_3:
       data 3
w_4:
       data 4
w_6:
       data 6
w_8:
       data 8
w_24:
       data 24
w_window_anim_type_resident:
       data window_anim_type_resident
w_map_width:
       data map_width
w_map_height:
       data map_height
*      For decimal printing - maintain order
w_10000:
       data 10000
w_1000:
       data 1000
w_100:
       data 100
w_10:
       data 10

buffer:
       bss  8

CTRL_LEFT_DN:
       equ  0
CTRL_LEFT_UP:
       equ  2
CTRL_RIGHT_DN:
       equ  4
CTRL_RIGHT_UP:
       equ  6
CTRL_LEFT_LT:
       equ  8
CTRL_LEFT_RT:
       equ  10
CTRL_RIGHT_LT:
       equ  12
CTRL_RIGHT_RT:
       equ  14
joystick_control:
       data JOY_DN, JOY_UP, JO2_DN, JO2_UP
       data JOY_LT, JOY_RT, JO2_LT, JO2_RT
keyboard_control:
       data KEY_D, KEY_E, KEY_K, KEY_I
       data KEY_S, KEY_F, KEY_J, KEY_L

levels:
       data level1
       data level2
       data level3
       data level4
level1:
       data level_1_bank_select
       data TCHARS1
       data RIDX1
       data ROWS1
       data PSTRIP1
       data CSTRIP1-PSTRIP1
       data progress_map_1
       data 100
       data 10000
       data stages1
level2:
       data level_2_bank_select
       data TCHARS2
       data RIDX2
       data ROWS2
       data PSTRIP2
       data CSTRIP2-PSTRIP2
       data progress_map_2
       data 150
       data 20000
       data stages2
level3:
       data level_3_bank_select
       data TCHARS3
       data RIDX3
       data ROWS3
       data PSTRIP3
       data CSTRIP3-PSTRIP3
       data progress_map_3
       data 200
       data 30000
       data stages3
level4:
       data level_4_bank_select
       data TCHARS4
       data RIDX4
       data ROWS4
       data PSTRIP4
       data CSTRIP4-PSTRIP4
       data progress_map_4
       data 250
       data 40000
       data stages4

*      Level dependent constants
current_level_data:
       equ  $
level_bank_select:
       data level_1_bank_select
trans_chars:
       data TCHARS1
map_row_index:
       data RIDX1
map_rows:
       data ROWS1
pattern_strips:
       data PSTRIP1
color_strip_offset:
       data CSTRIP1-PSTRIP1
progress_map:
       data progress_map_1
step_points:
       data 100
bonus_points:
       data 10000
stages:
       data stages1
level_data_size:
       equ  $-current_level_data

       copy "level-1-stages.a99"
       copy "level-2-stages.a99"
       copy "level-3-stages.a99"
       copy "level-4-stages.a99"

bird_init_data:
       data bird_handler, >0020, >0982, >0002, >0001, >0000
kong_init_data:
       data kong_handler, >0058, >0448, >0000, >0000, >0000
chopper_init_data:
       data chopper_handler, >0040, >0000, >0000, >0001, >0002

high_scores:
       data 1,34464
       data 0,50000
       data 0,20000
high_scores_2nd_last:
       data 0,10000
high_scores_last:
       data 0,5000

txt_highest_scores:
       byte >e7,>e8,>e6,>e7,>e4,>f2,>f3,>00,>f2,>e2,>ee,>f1,>e4,>f2

txt_no1:
       byte >ed,>ee,>61,>fd

window_anim_row:
       equ  0
window_anim_col:
       equ  2
window_anim_type:
       equ  4
window_anim_frame:
       equ  6
window_anim_count:
       equ  8
window_anim_next:
       equ  10
window_anim_prev:
       equ  12
window_anim_size:
       equ  14

window_anim_type_window:
       equ  0
window_anim_type_resident:
       equ  1

window_anims:
       bss  n_windows*window_anim_size
window_anims_end:
       data -1

base_scroll_chars:
       data 0
extra_scroll_chars:
       data 0
vdp_base_of_extra_scroll_chars:        ; index of first extra char * 8
       data 0
cpu_offset_to_extra_scroll_chars:      ; gap from last base char * 16
       data 0

base_tscs:
       equ  47

character_set_residents:
       data base_tscs                  ; base_scroll_chars
       data 16                         ; extra_scroll_chars
       data 47*8                       ; vdp_base_of_extra_scroll_chars
       data 0                          ; cpu_offset_to_extra_scroll_chars

character_set_door:
       data base_tscs                  ; base_scroll_chars
       data 17                         ; extra_scroll_chars
       data (base_tscs+16)*8           ; vdp_base_of_extra_scroll_chars
       data 16*16                      ; cpu_offset_to_extra_scroll_chars

character_set_kong:
       data base_tscs                  ; base_scroll_chars
       data 28                         ; extra_scroll_chars
       data (base_tscs+16+17)*8        ; vdp_base_of_extra_scroll_chars
       data (16+17)*16                 ; cpu_offset_to_extra_scroll_chars

character_set_sign:
       data base_tscs                  ; base_scroll_chars
       data 24                         ; extra_scroll_chars
       data (base_tscs+16+17)*8        ; vdp_base_of_extra_scroll_chars
       data (16+17)*16                 ; cpu_offset_to_extra_scroll_chars

sprite_pattern_sets:
       equ  $
head_and_hands_patterns:
       equ  0
       data SPR40                      ; Head and hands
chopper_patterns:
       equ  1
       data SPR64                      ; Chopper
bird_patterns:
       equ  2
       data SPR84                      ; Bird
kong_patterns:
       equ  3
       data SPR108                     ; Kong
balloon_patterns:
       equ  4
       data SPR124                     ; Balloon
girder_patterns:
       equ  5
       data SPR134                     ; Girders and dumbbells
spark_patterns:
       equ  6
       data SPR152                     ; Sign sparks

sprite_attributes_overlay:
       byte >ad,>a8,0,>09              ; Bottom, left
       byte >ad,>b8,0,>09              ; Bottom, right
       byte >9d,>a8,spr_lft_top_2nd_norm_1,>09 ; Top, left
       byte >9d,>b8,spr_rgt_top_2nd_norm_1,>09 ; Top, right
sprite_attributes_body:
       byte >9d,>a8,spr_lft_top_norm_1,>02
       byte >9d,>b8,spr_rgt_top_norm_1,>02
       byte >ad,>a8,spr_lft_bot_norm_1,>02
       byte >ad,>b8,spr_rgt_bot_norm_1,>02

sprite_handler:
       equ  0
sprite_y:
       equ  2
sprite_x:
       equ  4
sprite_count:
       equ  6
sprite_vy:
       equ  8
sprite_vx:
       equ  10
sprite_ay:
       equ  12
sprite_ax:
       equ  14
sprite_size:
       equ  16

       even
sprites:
       bss  n_sprites*sprite_size
sprites_end:
       equ  $

big_sprite_n_sprites:
       equ  0
* Followed by n times little sprites
big_sprite_dy:
       equ  0                          ; Y offset from last little sprite
big_sprite_dx:
       equ  1                          ; Y offset from last little sprite
big_sprite_pattern:
       equ  2
big_sprite_color:
       equ  3

*********************************************************************
*
*      Data includes
*
       copy "progress-map.a99"
       copy "sprite-patterns.a99"
       copy "map-animations.a99"
       copy "sprite-animations.a99"
       copy "sound-fx.a99"
       copy "intro-music.a99"
       copy "bird-music.a99"
       copy "kong-music.a99"
       copy "completed-music.a99"
       copy "speech-data.a99"

map_buffer:
       bss  >2486

       data -1

***************************************************************************
*
upper_memory_max:
       equ  $

       end  start
