*********************************************************************
*
* Crazy climber
*
* Rasmus Moustgaard <rasmus.moustgaard@gmail.com>
*
*********************************************************************

       def   start

       copy "macros.a99"

**
* Memory mapped addresses
*
vdpwd:                                 ; VDP write data
       equ  >8c00
vdpwa:                                 ; VDP set read/write address
       equ  >8c02
vdprd:                                 ; VDP read data
       equ  >8800
vdpsta:                                ; VDP status
       equ  >8802
sound:                                 ; Sound
       equ  >8400
spchwt:
       equ  >9400
spchrd:
       equ  >9000


*       VPD RAM Map
pattern_table:
       EQU  >0000                      ; Pattern table base
pattern_table_1:
       EQU  >0800                      ; Pattern table part 2
pattern_table_2:
       EQU  >1000                      ; Pattern table part 3
sprite_pattern_table:
       EQU  >1800                      ; Sprite pattern table (>03)
color_table:
       EQU  >2000                      ; Color table base
name_table_0:
       EQU  >2800                      ; Name table base 0 (>0A)
name_table_1:
       EQU  >2C00                      ; Name table base 1 (>0B)
name_table_2:
       EQU  >3000                      ; Name table base 2 (>0C)
name_table_3:
       EQU  >3400                      ; Name table base 3 (>0D)
sprite_attr_table:
       EQU  >3700                      ; Sprite attribute table (>6E)

*      Constants
map_width:
       equ   22
n_windows:
       equ  6
top_window_row_y:
       equ 128

**
* Scratch pad
*
pad:
       equ  >8300
wrksp:
       equ  pad                        ; Workspace
r0lb:
       equ  wrksp+1
r1lb:
       equ  wrksp+3
r2lb:
       equ  wrksp+5
r3lb:
       equ  wrksp+7
wrksp2:
       equ  wrksp+>20
stack:
       equ  wrksp2+>20
**
* PAD constants
*
padcon:
       equ  stack+>16                  ; Start of pad constants
one:
       equ  padcon
eight:
       equ  padcon+2
**
* PAD variables
*
padvar:                                ; Start of pad variables
       equ  eight+2
*********************************************************************
*
* Variables and data
*
rand_no:
       equ  padvar
vdp_status:
       equ  rand_no+2
frame:
       equ  vdp_status+2
scroll_y:
       equ  frame+2                    ; Vertical scroll offset
scroll_dy:
       equ  scroll_y+2                 ; Scroll direction (1 or -1)
scroll_dy_old:
       equ  scroll_dy+2                ; Scroll direction (1 or -1)
left_anim_ptr:
        equ  scroll_dy_old+2
right_anim_ptr:
        equ  left_anim_ptr+2
left_anim_count:
       equ  right_anim_ptr+2           ; Maximimum scroll offset
right_anim_count:
       equ  left_anim_count+2          ; Maximimum scroll offset
pad_max:
        equ  right_anim_count+2

********************************************************************************
*
* Main program
*
       aorg >a000                      ; load into upper memory
start  limi 0                          ; disable interrupts
       lwpi wrksp                      ; setup workspace
       li   r10,stack                  ; use r10 as stack pointer
       bl   @one_time_init
*      Init variables
       li   r0,>0bf7                   ; start at the bottom of the map
       mov  r0,@scroll_y
       clr  @scroll_dy
       clr  @scroll_dy_old
       clr  @frame
       li   r0,left_norm
       mov  r0,@left_anim_ptr
       clr  @right_anim_ptr
*      Display initial screen
       bl   @initial_screen
*      Scroll loop
main_loop:
*      Wait for vsync
       bl   @vsync
*      Set name table
       bl   @set_name_table
*      Update patterns
       bl   @update_pattern_table
*      Update name table buffer
       bl   @update_name_table
*      Animate windows and faces
       bl   @animate_windows
       bl   @create_windows
*      Display climber and other sprites
       bl   @display_sprites
*      Change scroll offset
       a    @scroll_dy,@scroll_y
       c    @scroll_dy,@scroll_dy_old
       jeq  main_loop_1
*      Update full name table when scroll increment changes
       bl   @update_full_name_table
       mov  @scroll_dy,@scroll_dy_old
main_loop_1:
*      Loop forever
       inc  @frame
       jmp  main_loop
*// main_loop

*********************************************************************
*
* Wait for vsync
*
* Modifies R0
*
vsync:
       movb @vdpsta,@vdp_status        ; clear flag if already set
       clr  r12
vsync1:
       tb   2
       jeq  vsync1
       socb @vdpsta,@vdp_status
       b    *r11
*// vsync

*********************************************************************
*
* Set name table
*
* Altenate between tables 0 and 1 in frames 0-7
* Alternate between tables 2 and 3 in frames 8-15
*
* Tables 0 and 2 contain 'names' from the low character set (0-127)
* Tables 1 and 3 contain 'names' from the high character set (128-255)
*
* Modifies R0
*
set_name_table:
       .proc
       mov  @frame,r0                  ; Get frame
       coc  @eight,r0                  ; check which table set to use
       jeq  setnt2
       coc  @one,r0                    ; check which table to use
       jeq  setnt1
       li   r0,>020a                   ; namet0
       jmp  setnt4
setnt1:
       li   r0,>020b                   ; namet1
       jmp  setnt4
setnt2:
       coc  @one,r0                    ; check which table to use
       jeq  setnt3
       li   r0,>020c                   ; namet2
       jmp  setnt4
setnt3:
       li   r0,>020d                   ; namet3
*      update VR2
setnt4:
       bl   @vwtr
       .endproc
*// set_name_table

*********************************************************************
*
* Update pattern and color tables
*
* Alternate between updating low (0-127) or high (128-255) half of
* the character set. The set that is updated is not used (and therefore
* not visible) in the currently displayed name table. This provides the
* desired double buffering effect.
*
* Magellan is exporting the patterns and colors in strips of 16 bytes,
* each strip representing the transition between two original characters.
* In terms of the Transition Character Pairs table it's the 'to' character
* (pattern or color) followed by the 'from' character (pattern or color).
*
* If sprites beyond 0-7 are to be used on a real 9918A VDP we need to update
* the second and third part of the pattern table as well (with the same
* patterns). The color table is always OK at >800 bytes. See GMODE.
*
* Modifies R0-R4
*
update_pattern_table:
       .proc
       mov  @frame,r3                  ; Read frame into register
*      Calculate VDP RAM destination address
       coc  @one,r3                    ; check which character set to update
       jeq  updpt1
       li   r0,pattern_table+>400      ; update high character set (128-255)
       jmp  updpt2
updpt1:
       li   r0,pattern_table           ; update low character set (128-255)
*      Calculate cpu ram source address
updpt2:
       mov  @scroll_y,r1               ; start with scroll offset
       a    @scroll_dy,r1              ; add direction (1 or -1)
       andi r1,>0007                   ; mod 8
       ai   r1,pstrip                  ; add base address of pattern strips
*      Save calculated values
       mov  r0,r4
       mov  r1,r5
*      Copy patterns 1st part
       mov  @tchnum,r2                 ; number of patterns
       bl   @vm8bw8
*      Copy patterns 2nd part
       mov   r4,r0
       ai    r0,>800
       mov   r5,r1
       mov   @tchnum,r2                ; number of patterns
       bl    @vm8bw8
*      Copy patterns 3rd part
       mov   r4,r0
       ai    r0,>1000
       mov   r5,r1
       mov   @tchnum,r2                ; number of patterns
       bl    @vm8bw8
*      Copy colors
       mov  r4,r0
       ai   r0,color_table
       mov  r5,r1
       ai   r1,cstrip-pstrip           ; add offset betweem patterns and colors
       mov  @tchnum,r2                 ; number of patterns
       bl   @vm8bw8
       .endproc
*// update_pattern_table

*********************************************************************
*
* Update name table off-screen buffer
*
* The prepared buffers have a one row (8 pixels) offset from
* from the currently visible buffers, allowing a smooth transition
* after we have scrolled 7 pixels.
*
* We altenate between updating table buffers 2 and 3 in frames 0-7
* We alternate between updating table buffers 0 and 1 in frames 8-15
*
* Since we have 8 frames to update two buffers we need to update
* 1/4 buffer each frame, i.e. 6 screen rows. First frame we update
* rows 0-5 of the first buffer. Second frame we update the same 6
* rows of the second buffer, but this time we set the most significant
* bit to use the high character set. Third frame we update rows 6-11
* of the first buffer, and so on.
*
* Note: As for SETNT we could also calculate the buffer number
* instead of using 'if' statements.
*
* Modifies R0-R4
*
update_name_table:
       .proc
       mov  @frame,r3                  ; Get frame
*      Calculate row offset to the 1/4 of the buffer to update
       mov  r3,r0                      ; start with frame number
       andi r0,>0006                   ; transform to sequence: 0,0,2,2,4,4,6,6...
       mov  r0,r2                      ; copy to r2
       sla  r0,1                       ; multiply by 2
       a    r0,r2                      ; add to r2 to multiply by 6 and get
*                                      ; row offset: 0,0,6,6,12,12,18,18...
       mov  r2,r0                      ; copy back into r0 for later
*      Calculate map source address in R1
       mov  @scroll_y,r1               ; get scroll offset in pixels
       srl  r1,3                       ; divide by 8 to get row offset
       a    @scroll_dy,r1              ; add dy: prepared buffer has a 1 row offset
       a    r2,r1                      ; add the row offset we calculated before
       mpy  @ms0,r1                    ; multiply by map width to get character offset in r2
       li   r1,md0                     ; get the map base address
       a    r2,r1                      ; add the character offset
*      calculate buffer destination address in r0
       sla  r0,5                       ; convert row offset to chcracter offset
*      decide which buffer to update
       coc  @eight,r3                  ; bit weight >08 determines the group
       jne  updnt2                     ; if not set we update buffer 2 or 3
       coc  @one,r3                    ; bit weight >01 determines the buffer
       jeq  updnt1
       ai   r0,name_table_0+8          ; add base address to character offset
       jmp  updnt4
updnt1:
       ai   r0,name_table_1+8          ; add base address to character offset
       jmp  updnt4
updnt2:
       coc  @one,r3                    ; bit weight >01 determines the buffer
       jeq  updnt3
       ai   r0,name_table_2+8          ; add base address to character offset
       jmp  updnt4
updnt3:
       ai   r0,name_table_3+8          ; add base address to character offset
*      copy to vdp ram buffer
updnt4:
       li   r4,6                       ; number of rows to copy
       coc  @one,r3                    ; high or low character set copy?
       jeq  updnt6
updnt5:
       bl   @copy_row                  ; low character set
       ai   r0,32
       dec  r4
       jne  updnt5
       jmp  updnt7
updnt6:
       bl   @copy_row_hi
       ai   r0,32
       dec  r4
       jne  updnt6
*      return
updnt7:
       .endproc
*// update_name_table

*********************************************************************
*
* Animate windows
*
animate_windows:
       .proc
       mov  @frame,r0                  ; Only do this every 8th frame
       andi r0,>0007
       ci   r0,7
       jne  animate_windows_5
       li   r3,windows                 ; List of window animations (inclusing resident faces)
animate_windows_1:
       mov  *r3+,r1                    ; Window y
       jlt  animate_windows_5          ; Negative terminates
       mov  *r3+,r0                    ; Window x (0 - 5)
       bl   @window_map_addr               ; Map address in r2
       mov  *r3+,r5                    ; Get animation type
       mov  *r3,r4                     ; Get animation frame
       sla  r4,1                       ; To word offset
       ci   r5,1                       ; Is it a face animation?
       jne  animate_windows_2          ; No - move on
       ai   r4,face_appear             ; Yes - add base address of face animations
       jmp  animate_windows_4
animate_windows_2:
       cb   @-22(r2),@byte_closed      ; Is window above closed?
       jeq  animate_windows_3          ; No - move on
       ai   r4,close_window_below_open ; Yes - add base address of closing windows below open animation
       jmp  animate_windows_4
animate_windows_3:
       ai   r4,close_window_below_closed ; Add base address of closing windows below closed animation
animate_windows_4:
       mov  *r4,r4                     ; Get address of animation bytes
       movb *r4+,*r2+                  ; Top row
       movb *r4+,*r2
       ai   r2,map_width-1             ; Next row
       movb *r4+,*r2+                  ; Middle row
       movb *r4+,*r2
       ai   r2,map_width-1             ; Next row
       movb *r4+,*r2+                  ; Bottom row
       movb *r4+,*r2
*      Update animation frame
       mov  *r3,r4                     ; Get animation frame
       inc  r4                         ; Increment animation frame
       andi r4,>000f                   ; Wrap at 16
       mov  r4,*r3+                    ; Write it back
       ci   r4,>0007                   ; Is it frame 8?
       jne  animate_windows_1          ; No - next window
       c    @window_anim-window_size(r3),@one ; Is it a face animation?
       jne  animate_windows_1          ; No - next window
       bl   @create_resident           ; Create a new resident sprite
       jmp  animate_windows_1          ; Next window
animate_windows_5:
       .endproc
*// animate_windows

*********************************************************************
*
* Create window animations
*
create_windows:
       .proc
       mov  @frame,r0
       andi r0,>000f
       ci   r0,15
       jne  update_windows_2
       mov  @scroll_y,r3
       srl  r3,4                       ; Number of windows scrolled
       ai   r3,12-8                    ; Y coord of bottom window row on screen
       c    r3,@windows_last
       jhe  update_windows_2
       li   r0,windows_2nd_last
       li   r1,windows_last
*      Shift windows list down
       li   r2,n_windows-1             ; Number of windows
create_windows_1:
       mov  *r0+,*r1+
       mov  *r0+,*r1+
       mov  *r0+,*r1+
       mov  *r0+,*r1+
       ai   r0,-16
       ai   r1,-16
       dec  r2
       jne  create_windows_1
*      Add new window
       li   r2,6                       ; X coord between 0 and 5
       bl   @rand_max
       mov  r3,r1                      ; Y coord of bottom window row on screen
       ai   r1,-12                     ; Y coord of top window row on screen
       bl   @window_map_addr               ; Window address in r2
       cb   *r2,@byte_open             ; Is there an open window?
       jne  update_windows_2           ; If not then skip
       li   r3,windows
       mov  r1,*r3+                    ; Write Y coord
       mov  r0,*r3+                    ; Write X coord
       bl   @rand
       andi r0,1                       ; Set type
       mov  r0,*r3+                    ; 0 = empty window, 1 = window with resident
       clr  *r3                        ; Clear frame
update_windows_2:
       .endproc
*// update_windows

*********************************************************************
*
* Display sprites
*
display_sprites:
       .proc
       li   r0,sprite_attr_table
       bl   @vwad
       bl   @animate_climber
       bl   @handle_other_sprites
       li   r1,>d000                   ; Write end marker
       movb r1,*r15
       .endproc
*// display_sprites

*********************************************************************
*
* Animate climber
*
animate_climber:
       .proc
animate_climber_0:
       mov  @left_anim_ptr,r0
       jeq  animate_climber_3
       mov  @left_anim_count,r1
       jne  animate_climber_1
       mov  *r0+,r1
       jeq  animate_climber_2
       mov  *r0+,r2
       movb *r2,@sprite_attributes_head+2
       mov  *r0+,@scroll_dy
       mov  *r0+,@left_anim_count
       mov  r0,@left_anim_ptr
       movb *r1+,@sprite_attributes_body+2
       movb *r1+,@sprite_attributes_body+6
animate_climber_1:
       dec  @left_anim_count
       jmp  animate_climber_3
animate_climber_2:
       clr  @left_anim_ptr
       li   r0,right_norm
       mov  r0,@right_anim_ptr
animate_climber_3:
       mov  @right_anim_ptr,r0
       jeq  animate_climber_6
       mov  @right_anim_count,r1
       jne  animate_climber_4
       mov  *r0+,r1
       jeq  animate_climber_5
       mov  *r0+,r2
       movb *r2,@sprite_attributes_head+6
       mov  *r0+,@scroll_dy
       mov  *r0+,@right_anim_count
       mov  r0,@right_anim_ptr
       movb *r1+,@sprite_attributes_body+10
       movb *r1+,@sprite_attributes_body+14
animate_climber_4:
       dec  @right_anim_count
       jmp  animate_climber_6
animate_climber_5:
       clr  @right_anim_ptr
       li   r0,left_norm
       mov  r0,@left_anim_ptr
       jmp  animate_climber_0
animate_climber_6:
       mov  @vdp_status,r0
       andi r0,>4000                   ; Test 5th sprite flag
       jeq  animate_climber_7
       li   r1,sprite_attributes_body
       li   r2,2
       jmp  animate_climber_8
animate_climber_7:
       li   r1,sprite_attributes_head
       li   r2,3
animate_climber_8:
       bl   @vdp_copy
       .endproc
*// animate_climber

*********************************************************************
*
* Handle other sprites
*
handle_other_sprites:
       .proc
       li   r3,sprites
handle_other_sprites_1:
       mov  *r3,r0
       jeq  handle_other_sprites_2
       bl   *r0
handle_other_sprites_2:
       ai   r3,sprite_size
       ci   r3,sprites_end
       jl   handle_other_sprites_1
       .endproc
*// handle_other_sprites

*********************************************************************
*
* Resident person handler
*
* r3: sprite structure
*
resident_handler:
       .proc
       mov  @sprite_count(r3),r0       ; Init?
       jne  resident_handler_1         ; Jump if not
       li   r0,48
       mov  r0,@sprite_count(r3)
resident_handler_1:
       mov  @sprite_x(r3),r0
       mov  @sprite_y(r3),r1
       bl   @window_screen_coords
       dec  r1
       swpb r1
       movb r1,*r15
       swpb r0
       movb r0,*r15
       li   r0,spr_resident*256
       movb r0,*r15
       li   r0,>0f00                   ; White
       movb r0,*r15
       c    @sprite_count(r3),@resident_handler_drop
       jne  resident_handler_2
       bl   @rand
       ci   r0,>c000
       jl   resident_handler_2
       bl   @create_plant
resident_handler_2:
       dec  @sprite_count(r3)
       jne  resident_handler_3
       clr  *r3                        ; Handler done
resident_handler_3:
       .endproc
resident_handler_drop:
       data 32
*// resident_handler

*********************************************************************
*
* Dropping plant handler
*
* r3: sprite structure
*
plant_handler:
       .proc
       mov  @sprite_y(r3),r1
       dec  r1
       swpb r1
       movb r1,*r15
       mov  @sprite_x(r3),r0
       swpb r0
       movb r0,*r15
       li   r0,spr_plant_1*256
       movb r0,*r15
       li   r0,>0c00                   ; Green
       movb r0,*r15
       mov  @sprite_y(r3),r0
       s    @scroll_dy,r0
       inc  r0
       mov  r0,@sprite_y(r3)
       ci   r0,194
       jl   plant_handler_1
       clr  @sprite_handler(r3)
plant_handler_1:
       .endproc
*// plant_handler

*********************************************************************
*
* Create resident
*
* r3 points to window structure of next window (must be preserved)
*
create_resident:
       .proc
       bl   @allocate_sprite
       mov  r4,r4
       jeq  create_resident_1
       li   r0,resident_handler
       mov  r0,*r4+                            ; Handler
       mov  @window_row-window_size(r3),*r4+   ; y
       mov  @window_col-window_size(r3),*r4+   ; x
       clr  *r4                                ; Counter
create_resident_1:
       .endproc
*// create_resident

*********************************************************************
*
* Create plant
*
* r3 points to sprite structure of resident (must be preserved)
*
create_plant:
       .proc
       bl   @allocate_sprite
       mov  r4,r4
       jeq  create_plant_1
       li   r0,plant_handler
       mov  r0,*r4+                    ; Handler
       mov  @sprite_x(r3),r0
       mov  @sprite_y(r3),r1
       bl   @window_screen_coords
       ai   r1,16
       mov  r1,*r4+                    ; y
       mov  r0,*r4+                    ; x
       clr  *r4                        ; Counter
create_plant_1:
       .endproc
*// create_plant

*********************************************************************
*
* Allocate sprite
*
* Return sprite address in r4 or zero if no sprte available
*
allocate_sprite:
       li   r4,sprites
allocate_sprite_1:
       mov  *r4,*r4
       jeq  allocate_sprite_2
       ai   r4,sprite_size
       ci   r4,sprites_end
       jne  allocate_sprite_1
       clr  r4
allocate_sprite_2:
       rt
*// allocate_sprite

*********************************************************************
*
* Update full name table off-screen buffers
*
* If the direction of scrolling, @SCRLDY, is changed in the middle of
* a frame cycle, the part of the off-screen buffers that has already
* been prepared will become invalid. When scrolling up it should be safe
* to change direction (to down) in frames 0 and 8, and when scrolling
* down it should be safe to change direction (to up) in frames 7 and 15.
* Otherwise this routine should be called.
*
* This implementation is simply calling the incremental update routine,
* UPDNT, 8 times. It could be done more efficient, but code reusing is
* also a virtue.
*
* Modifies R0-R4
*
update_full_name_table:
       .proc
       mov  @frame,r3
       .push r3                        ; push current frame onto the stack
       andi r3,>0008                   ; move to beginning of frame cycle (0 or 8)
       mov  r3,@frame
upntf1:
       bl   @update_name_table         ; call the incremental update routine
       inc  @frame                     ; next frame
       mov  @frame,r3
       andi r3,>0007                   ; check for end of cycle
;      jne  upntf1                     ; For now we only need to draw the top part
*      return
       dect r10                        ; pop frame off the stack
       mov  *r10,@frame
       .endproc
*// update_full_name_table

*********************************************************************
*
* Window address in map
*
* r0: window column
* r1: window row
*
* On return r2 contains the address in the map
*
window_map_addr:
       .push r1
       mpy  @MS0,r1                    ; Multiply by map width to r2
       sla  r2,1                       ; Two rows per window
       ai   r2,top_window_row+2        ; Add address of top of building + offset for left wall
       a    r0,r2                      ; Add x to address x 1
       a    r0,r2                      ; Add x to address x 2
       a    r0,r2                      ; Add x to address x 3
       .pop r1
       rt
*// window_map_addr

*********************************************************************
*
* Window screen coordinates
*
* r0: window column
* r1: window row
*
* On return r0 and r1 contain the screen coordinates (x, y), r2 is modified
*
window_screen_coords:
       sla  r0,3                       ; column * 8
       mov  r0,r2
       sla  r0,1                       ; column * 16
       a    r2,r0                      ; column * 24
       ai   r0,>50                     ; Add offset from left
       sla  r1,4                       ; row * 16
       s    @scroll_y,r1               ; Minus scroll offsset
       ai   r1,top_window_row_y
       rt
*// window_screen_coords

*********************************************************************
*
* Generate a pseudo random number within the given limit
*
* R2: Maximum number (0 - 255) exclusive
*
* On return R0 contains the number [0; R1[
*
rand_max:
       .proc
       bl   @rand                      ; generate a random number in r0
       andi r0,>00ff                   ; clear msb: [0-255]
       mpy  r2,r0                      ; width * [0-255]
       srl  r1,8                       ; (width * [0-255]) / 256
       mov  r1,r0                      ; copy result back
       .endproc
*// rand_max

*********************************************************************
*
* Generate a pseudo random number
*
* On return R0 contains the number, which is also stored at @RANDNO
*
* r0 and r1 are modified
*
rand:
       li   r0,28643                   ; A prime number to multiply by
       mpy  @rand_no,r0                ; Multiply by last random number
       ai   r1,31873                   ; Add a prime number
       src  r1,7                       ; Mix up the number to break odd/even pattern
       mov  r1,@rand_no                ; Save this number for next time
       mov  r1,r0
       rt
*// rand

*********************************************************************
*
* Display initial screen
*
* If sprites beyond 0-7 are to be used on a real 9918A VDP we need to update
* the second and third part of the pattern table as well (with the same 
* patterns). The color table is always OK at >800 bytes. See GMODE.
*
* Note that the pattern frame that should be uploaded here depends on the 
* initial direction of the scrolling. If you want to start at the bottom 
* you should start at frame 7 or 15, to allow enouh frames for building 
* the next name table. This means that the address PSTRIP+7 should be used
* instead of PSTRIP, and @SCRLY should be initilized so that the 3 least 
* significant bits are all ones, e.g. 511 - not 512.
*
initial_screen:
       .proc
*      Upload patterns 1st part
       li   r0,65*8+pattern_table      ; Non-scrolling characters
       li   r1,PAT65
       li   r2,55*8
       bl   @vmbw
       li   r0,pattern_table+>400      ; destination address in vdp ram
       li   r1,PSTRIP+7                ; address of first scrolled pattern frame
       mov  @tchnum,r2                 ; number of patterns of 8 bytes
       bl   @vm8bw8                    ; call copying routine
*      Upload patterns 2nd part
       li   r0,65*8+pattern_table_1    ; Non-scrolling characters
       li   r1,PAT65
       li   r2,55*8
       bl   @vmbw
       li   r0,pattern_table_1         ; destination address in vdp ram
       li   r1,PSTRIP+7                ; address of first scrolled pattern frame
       mov  @tchnum,r2                 ; number of patterns of 8 bytes
       bl   @vm8bw8                    ; call copying routine
*      Upload patterns 3rd part
       li   r0,65*8+pattern_table_2    ; Non-scrolling characters
       li   r1,PAT65
       li   r2,55*8
       bl   @vmbw
       li   r0,pattern_table_2         ; destination address in vdp ram
       li   r1,PSTRIP+7                ; address of first scrolled pattern frame
       mov  @tchnum,r2                 ; number of patterns of 8 bytes
       bl   @vm8bw8                    ; call copying routine
*      Upload colors
       li   r0,65*8+color_table        ; Non-scrolling colors
       li   r1,COL65
       li   r2,55*8
       bl   @vmbw
       LI   R0,color_table+>400        ; Destination address in VDP RAM
       li   r1,CSTRIP+7                ; address of first scrolled color frame
       mov  @tchnum,r2                 ; number of pattern colors of 8 bytes
       bl   @vm8bw8                    ; call copying routine
*      Init name tables
       mov  @scroll_y,r4               ; get initial scroll offset in pixels
       srl  r4,3                       ; convert to row offset
       mov  r4,r5
       sla  r4,5                       ; convert to name table offset
       mpy  @MS0,r5                    ; convert to map offset in r6
*      Table 0
       li   r0,name_table_0
       li   r1,MD2
       li   r2,>300
       bl   @vmbw
       li   r0,name_table_0+8          ; destination address in vdp ram
       li   r1,md0                     ; base address of map data
       a    r6,r1                      ; add map offset
       li   r7,24                      ; number of rows
inisc1:
       bl   @copy_row
       ai   r0,32
       dec  r7
       jne  inisc1
*      Table 1
       li   r0,name_table_1
       li   r1,MD2
       li   r2,>300
       bl   @vmbw
       li   r0,name_table_1+8          ; destination address in vdp ram
       li   r1,MD0                     ; base address of map data
       a    r6,r1                      ; add map offset
       li   r7,24                      ; number of rows
inisc2:
       bl   @copy_row_hi
       ai   r0,32
       dec  r7
       jne  inisc2
*      Table 2
       li   r0,name_table_2
       li   r1,MD2
       li   r2,>300
       bl   @vmbw
*      Table 3
       li   r0,name_table_3
       li   r1,MD2
       li   r2,>300
       bl   @vmbw
       .endproc
*// initial_screen

*********************************************************************
*
* One time initializations
*
one_time_init:
       .proc
       li   r15,vdpwd
       li   r0,1
       mov  r0,@one
       li   r0,8
       mov  r0,@eight
       mov  @>83c0,@rand_no
*      Clear scratchpad
       li   r0,padvar
       li   r2,pad_max-padvar
       bl   @clear
*      setup graphics mode
       bl   @graphics_mode             ; call setup routine
*      Sprite patterns
       li   r0,sprite_pattern_table
       li   r1,SPR0
       li   r2,64*32
       bl   @vmbw
*      Sprite attributes
       li   r0,sprite_attr_table
       li   r1,sprite_attributes_body
       li   r2,16
       bl   @vmbw
*      Clear sprites table
       li   r0,sprites
       li   r2,sprites_end-sprites
       bl   @clear
       .endproc
*// one_time_init

*********************************************************************
*
* Set graphics mode
*
graphics_mode:
       .proc
       clr  r0
       li   r1,vdp_registers
       li   r2,8
graphics_mode_1:
       movb *r1+,@r0lb
       bl   @vwtr                      ; Set register
       ai   r0,>0100
       dec  r2
       jne  graphics_mode_1
*      Clear VDP RAM
       clr  r0
       clr  r1
       li   r2,>4000
       bl   @vsmw
*      Disable sprites
       li   r0,sprite_attr_table
       li   r1,>d000
       bl   @vsbw
       .endproc
*      VDP registers
vdp_registers:
       byte >02                        ; Graphics II mode
       byte >c2                        ; 16K, display on, no interrupt
       byte name_table_0/>400          ; Name table
       byte >9f                        ; Color table
       byte pattern_table/>800+>03     ; Pattern table x 3
       byte sprite_attr_table/>80      ; Sprite attribute table
       byte sprite_pattern_table/>800  ; Sprite pattern table
       byte >07                        ; Backdrop color
*// graphics_mode

*********************************************************************
*
* Clear CPU memory
*
clear:
       clr  *r0+
       dect r2
       jne  clear
       rt
*// clear

*********************************************************************
*
*       Includes
*
       copy "vdp.a99"

*********************************************************************
*
*       Data
*
       copy "graphics.a99"
       copy "screen.a99"
       copy "sprite-patterns.a99"
       copy "map-animations.a99"
       copy "sprite-animations.a99"

window_row:
       equ  0
window_col:
       equ  2
window_anim:
       equ  4
window_frame:
       equ  6
window_size:
       equ  8

windows:
       data 177,4,0,14
       data 179,3,1,1
       data 180,3,0,7
       data 183,5,0,0
windows_2nd_last:
       data 184,2,0,2
windows_last:
       data 186,0,0,0
       data -1
byte_closed:
       byte >00
byte_open:
       byte >36

sprite_attributes_head:
       byte >5f,>a8,spr_lft_top_2nd_norm_1,>06
       byte >5f,>b8,spr_rgt_top_2nd_norm_1,>06
sprite_attributes_body:
       byte >5f,>a8,spr_lft_top_norm_1,>02
       byte >6f,>a8,spr_lft_bot_norm_1,>02
       byte >5f,>b8,spr_rgt_top_norm_1,>02
       byte >6f,>b8,spr_rgt_bot_norm_1,>02

sprite_handler:
       equ  0
sprite_y:
       equ  2
sprite_x:
       equ  4
sprite_count:
       equ  6
sprite_size:
       equ  8

       even
sprites:
       bss 16*sprite_size
sprites_end:
       equ  $

       end  start
